{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/span-attributes-with-logic-attached.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/span-attributes-with-logic-attached.ts"],"sourcesContent":["/**\n * If this attribute is attached to a transaction, the Next.js SDK will drop that transaction.\n */\nexport const TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION = 'sentry.drop_transaction';\n\nexport const TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL = 'sentry.sentry_trace_backfill';\n\nexport const TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL = 'sentry.route_backfill';\n"],"names":[],"mappings":"AAAA;;CAEA;;;;;;;;AACO,MAAM,wCAAA,GAA2C;AAEjD,MAAM,sCAAA,GAAyC;AAE/C,MAAM,sCAAA,GAAyC"}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/addHeadersAsAttributes.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/addHeadersAsAttributes.ts"],"sourcesContent":["import type { Span, WebFetchHeaders } from '@sentry/core';\nimport { httpHeadersToSpanAttributes, winterCGHeadersToDict } from '@sentry/core';\n\n/**\n * Extracts HTTP request headers as span attributes and optionally applies them to a span.\n */\nexport function addHeadersAsAttributes(\n  headers: WebFetchHeaders | Headers | Record<string, string | string[] | undefined> | undefined,\n  span?: Span,\n): Record<string, string> {\n  if (!headers) {\n    return {};\n  }\n\n  const headersDict: Record<string, string | string[] | undefined> =\n    headers instanceof Headers || (typeof headers === 'object' && 'get' in headers)\n      ? winterCGHeadersToDict(headers as Headers)\n      : headers;\n\n  const headerAttributes = httpHeadersToSpanAttributes(headersDict);\n\n  if (span) {\n    span.setAttributes(headerAttributes);\n  }\n\n  return headerAttributes;\n}\n"],"names":[],"mappings":";;;;;;AAGA;;CAEA,GACO,SAAS,sBAAsB,CACpC,OAAO,EACP,IAAI;IAEJ,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO,CAAA,CAAE;IACX;IAEA,MAAM,WAAW,GACf,OAAA,YAAmB,OAAA,IAAY,OAAO,OAAA,KAAY,QAAA,IAAY,KAAA,IAAS,OAAO,OAC1E,qMAAqB,EAAC,OAAA,IACtB,OAAO;IAEb,MAAM,gBAAA,OAAmB,2MAA2B,EAAC,WAAW,CAAC;IAEjE,IAAI,IAAI,EAAE;QACR,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC;IACtC;IAEA,OAAO,gBAAgB;AACzB"}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/nextSpanAttributes.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/nextSpanAttributes.ts"],"sourcesContent":["export const ATTR_NEXT_SPAN_TYPE = 'next.span_type';\nexport const ATTR_NEXT_SPAN_NAME = 'next.span_name';\nexport const ATTR_NEXT_ROUTE = 'next.route';\n"],"names":[],"mappings":";;;;;;;;AAAO,MAAM,mBAAA,GAAsB;AAC5B,MAAM,mBAAA,GAAsB;AAC5B,MAAM,eAAA,GAAkB"}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/dropMiddlewareTunnelRequests.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/dropMiddlewareTunnelRequests.ts"],"sourcesContent":["import { SEMATTRS_HTTP_TARGET } from '@opentelemetry/semantic-conventions';\nimport { GLOBAL_OBJ, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, type Span, type SpanAttributes } from '@sentry/core';\nimport { isSentryRequestSpan } from '@sentry/opentelemetry';\nimport { ATTR_NEXT_SPAN_TYPE } from '../nextSpanAttributes';\nimport { TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION } from '../span-attributes-with-logic-attached';\n\nconst globalWithInjectedValues = GLOBAL_OBJ as typeof GLOBAL_OBJ & {\n  _sentryRewritesTunnelPath?: string;\n};\n\n/**\n * Drops spans for tunnel requests from middleware or fetch instrumentation.\n * This catches both:\n * 1. Requests to the local tunnel route (before rewrite)\n * 2. Requests to Sentry ingest (after rewrite)\n */\nexport function dropMiddlewareTunnelRequests(span: Span, attrs: SpanAttributes | undefined): void {\n  // Only filter middleware spans or HTTP fetch spans\n  const isMiddleware = attrs?.[ATTR_NEXT_SPAN_TYPE] === 'Middleware.execute';\n  // The fetch span could be originating from rewrites re-writing a tunnel request\n  // So we want to filter it out\n  const isFetchSpan = attrs?.[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] === 'auto.http.otel.node_fetch';\n\n  // If the span is not a middleware span or a fetch span, return\n  if (!isMiddleware && !isFetchSpan) {\n    return;\n  }\n\n  // Check if this is either a tunnel route request or a Sentry ingest request\n  const isTunnel = isTunnelRouteSpan(attrs || {});\n  const isSentry = isSentryRequestSpan(span);\n\n  if (isTunnel || isSentry) {\n    // Mark the span to be dropped\n    span.setAttribute(TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION, true);\n  }\n}\n\n/**\n * Checks if a span's HTTP target matches the tunnel route.\n */\nfunction isTunnelRouteSpan(spanAttributes: Record<string, unknown>): boolean {\n  const tunnelPath = globalWithInjectedValues._sentryRewritesTunnelPath || process.env._sentryRewritesTunnelPath;\n  if (!tunnelPath) {\n    return false;\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = spanAttributes[SEMATTRS_HTTP_TARGET];\n\n  if (typeof httpTarget === 'string') {\n    // Extract pathname from the target (e.g., \"/tunnel?o=123&p=456\" -> \"/tunnel\")\n    const pathname = httpTarget.split('?')[0] || '';\n\n    return pathname.startsWith(tunnelPath);\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAMA,MAAM,wBAAA,GAA2B,4LAAA;AAIjC;;;;;CAKA,GACO,SAAS,4BAA4B,CAAC,IAAI,EAAQ,KAAK,EAAoC;IAClG,mDAAA;IACE,MAAM,eAAe,KAAK,EAAA,CAAG,iNAAmB,CAAA,KAAM,oBAAoB;IAC5E,gFAAA;IACA,8BAAA;IACE,MAAM,cAAc,KAAK,EAAA,CAAG,kNAAgC,CAAA,KAAM,2BAA2B;IAE/F,+DAAA;IACE,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE;QACjC;IACF;IAEF,4EAAA;IACE,MAAM,WAAW,iBAAiB,CAAC,KAAA,IAAS,CAAA,CAAE,CAAC;IAC/C,MAAM,QAAA,OAAW,iNAAmB,EAAC,IAAI,CAAC;IAE1C,IAAI,QAAA,IAAY,QAAQ,EAAE;QAC5B,8BAAA;QACI,IAAI,CAAC,YAAY,CAAC,mQAAwC,EAAE,IAAI,CAAC;IACnE;AACF;AAEA;;CAEA,GACA,SAAS,iBAAiB,CAAC,cAAc,EAAoC;IAC3E,MAAM,UAAA,GAAa,wBAAwB,CAAC,yBAAA,IAA6B,OAAO,CAAC,GAAG,CAAC,yBAAyB;IAC9G,IAAI,CAAC,UAAU,EAAE;;IAInB,mDAAA;IACE,MAAM,UAAA,GAAa,cAAc,CAAC,yOAAoB,CAAC;IAEvD,IAAI,OAAO,UAAA,KAAe,QAAQ,EAAE;QACtC,8EAAA;QACI,MAAM,QAAA,GAAW,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA,IAAK,EAAE;QAE/C,OAAO,QAAQ,CAAC,UAAU,CAAC,UAAU,CAAC;IACxC;IAEA,OAAO,KAAK;AACd"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/isBuild.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/isBuild.ts"],"sourcesContent":["import { PHASE_PRODUCTION_BUILD } from 'next/constants';\n\n/**\n * Decide if the currently running process is part of the build phase or happening at runtime.\n */\nexport function isBuild(): boolean {\n  return process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD;\n}\n"],"names":[],"mappings":";;;;;;AAEA;;CAEA,GACO,SAAS,OAAO,GAAY;IACjC,OAAO,OAAO,CAAC,GAAG,CAAC,UAAA,KAAe,mKAAsB;AAC1D"}},
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/debug-build.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/debug-build.ts"],"sourcesContent":["declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n"],"names":[],"mappings":"AAEA;;;;CAIA;;;;AACO,MAAM,WAAA,GAAc,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/responseEnd.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/responseEnd.ts"],"sourcesContent":["import type { Span } from '@sentry/core';\nimport { debug, fill, flush, GLOBAL_OBJ, setHttpStatus, vercelWaitUntil } from '@sentry/core';\nimport type { ServerResponse } from 'http';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ResponseEndMethod, WrappedResponseEndMethod } from '../types';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nexport function autoEndSpanOnResponseEnd(span: Span, res: ServerResponse): void {\n  const wrapEndMethod = (origEnd: ResponseEndMethod): WrappedResponseEndMethod => {\n    return function sentryWrappedEnd(this: ServerResponse, ...args: unknown[]) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end as WrappedResponseEndMethod).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nexport function finishSpan(span: Span, res: ServerResponse): void {\n  setHttpStatus(span, res.statusCode);\n  span.end();\n}\n\n/**\n * Flushes pending Sentry events with a 2 second timeout and in a way that cannot create unhandled promise rejections.\n */\nexport async function flushSafelyWithTimeout(): Promise<void> {\n  try {\n    DEBUG_BUILD && debug.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && debug.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && debug.log('Error while flushing events:\\n', e);\n  }\n}\n\n/**\n * Uses platform-specific waitUntil function to wait for the provided task to complete without blocking.\n */\nexport function waitUntil(task: Promise<unknown>): void {\n  // If deployed on Cloudflare, use the Cloudflare waitUntil function to flush the events\n  if (isCloudflareWaitUntilAvailable()) {\n    cloudflareWaitUntil(task);\n    return;\n  }\n\n  // otherwise, use vercel's\n  vercelWaitUntil(task);\n}\n\ntype MinimalCloudflareContext = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  waitUntil(promise: Promise<any>): void;\n};\n\n/**\n * Gets the Cloudflare context from the global object.\n * Relevant to opennext\n * https://github.com/opennextjs/opennextjs-cloudflare/blob/b53a046bd5c30e94a42e36b67747cefbf7785f9a/packages/cloudflare/src/cli/templates/init.ts#L17\n */\nfunction _getOpenNextCloudflareContext(): MinimalCloudflareContext | undefined {\n  const openNextCloudflareContextSymbol = Symbol.for('__cloudflare-context__');\n\n  return (\n    GLOBAL_OBJ as typeof GLOBAL_OBJ & {\n      [openNextCloudflareContextSymbol]?: {\n        ctx: MinimalCloudflareContext;\n      };\n    }\n  )[openNextCloudflareContextSymbol]?.ctx;\n}\n\n/**\n * Function that delays closing of a Cloudflare lambda until the provided promise is resolved.\n */\nexport function cloudflareWaitUntil(task: Promise<unknown>): void {\n  _getOpenNextCloudflareContext()?.waitUntil(task);\n}\n\n/**\n * Checks if the Cloudflare waitUntil function is available globally.\n */\nexport function isCloudflareWaitUntilAvailable(): boolean {\n  return typeof _getOpenNextCloudflareContext()?.waitUntil === 'function';\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AA4CA;;CAEA,GACO,eAAe,sBAAsB,GAAkB;IAC5D,IAAI;QACF,qMAAA,IAAe,6LAAK,CAAC,GAAG,CAAC,oBAAoB,CAAC;QAC9C,UAAM,4KAAK,EAAC,IAAI,CAAC;QACjB,qMAAA,IAAe,6LAAK,CAAC,GAAG,CAAC,sBAAsB,CAAC;IAClD,CAAA,CAAE,OAAO,CAAC,EAAE;QACV,qMAAA,IAAe,6LAAK,CAAC,GAAG,CAAC,gCAAgC,EAAE,CAAC,CAAC;IAC/D;AACF;AAEA;;CAEA,GACO,SAAS,SAAS,CAAC,IAAI,EAA0B;IACxD,uFAAA;IACE,IAAI,8BAA8B,EAAE,EAAE;QACpC,mBAAmB,CAAC,IAAI,CAAC;QACzB;IACF;IAEF,0BAAA;QACE,uMAAe,EAAC,IAAI,CAAC;AACvB;AAOA;;;;CAIA,GACA,SAAS,6BAA6B,GAAyC;IAC7E,MAAM,kCAAkC,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC;IAE5E,OAAO,AACL,4LAAA,AAKJ,CAAI,+BAA+B,CAAC,EAAE,GAAG;AACzC;AAEA;;CAEA,GACO,SAAS,mBAAmB,CAAC,IAAI,EAA0B;IAChE,6BAA6B,EAAE,EAAE,SAAS,CAAC,IAAI,CAAC;AAClD;AAEA;;CAEA,GACO,SAAS,8BAA8B,GAAY;IACxD,OAAO,OAAO,6BAA6B,EAAE,EAAE,SAAA,KAAc,UAAU;AACzE"}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/urls.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/urls.ts"],"sourcesContent":["import { getSanitizedUrlStringFromUrlObject, parseStringToURLObject } from '@sentry/core';\n\ntype ComponentRouteParams = Record<string, string> | undefined;\ntype HeadersDict = Record<string, string> | undefined;\n\nconst HeaderKeys = {\n  FORWARDED_PROTO: 'x-forwarded-proto',\n  FORWARDED_HOST: 'x-forwarded-host',\n  HOST: 'host',\n  REFERER: 'referer',\n} as const;\n\n/**\n * Replaces route parameters in a path template with their values\n * @param path - The path template containing parameters in [paramName] format\n * @param params - Optional route parameters to replace in the template\n * @returns The path with parameters replaced\n */\nexport function substituteRouteParams(path: string, params?: ComponentRouteParams): string {\n  if (!params || typeof params !== 'object') return path;\n\n  let resultPath = path;\n  for (const [key, value] of Object.entries(params)) {\n    resultPath = resultPath.split(`[${key}]`).join(encodeURIComponent(value));\n  }\n  return resultPath;\n}\n\n/**\n * Normalizes a path by removing route groups\n * @param path - The path to normalize\n * @returns The normalized path\n */\nexport function sanitizeRoutePath(path: string): string {\n  const cleanedSegments = path\n    .split('/')\n    .filter(segment => segment && !(segment.startsWith('(') && segment.endsWith(')')));\n\n  return cleanedSegments.length > 0 ? `/${cleanedSegments.join('/')}` : '/';\n}\n\n/**\n * Constructs a full URL from the component route, parameters, and headers.\n *\n * @param componentRoute - The route template to construct the URL from\n * @param params - Optional route parameters to replace in the template\n * @param headersDict - Optional headers containing protocol and host information\n * @param pathname - Optional pathname coming from parent span \"http.target\"\n * @returns A sanitized URL string\n */\nexport function buildUrlFromComponentRoute(\n  componentRoute: string,\n  params?: ComponentRouteParams,\n  headersDict?: HeadersDict,\n  pathname?: string,\n): string {\n  const parameterizedPath = substituteRouteParams(componentRoute, params);\n  // If available, the pathname from the http.target of the HTTP request server span takes precedence over the parameterized path.\n  // Spans such as generateMetadata and Server Component rendering are typically direct children of that span.\n  const path = pathname ?? sanitizeRoutePath(parameterizedPath);\n\n  const protocol = headersDict?.[HeaderKeys.FORWARDED_PROTO];\n  const host = headersDict?.[HeaderKeys.FORWARDED_HOST] || headersDict?.[HeaderKeys.HOST];\n\n  if (!protocol || !host) {\n    return path;\n  }\n\n  const fullUrl = `${protocol}://${host}${path}`;\n\n  const urlObject = parseStringToURLObject(fullUrl);\n  if (!urlObject) {\n    return path;\n  }\n\n  return getSanitizedUrlStringFromUrlObject(urlObject);\n}\n\n/**\n * Returns a sanitized URL string from the referer header if it exists and is valid.\n *\n * @param headersDict - Optional headers containing the referer\n * @returns A sanitized URL string or undefined if referer is missing/invalid\n */\nexport function extractSanitizedUrlFromRefererHeader(headersDict?: HeadersDict): string | undefined {\n  const referer = headersDict?.[HeaderKeys.REFERER];\n  if (!referer) {\n    return undefined;\n  }\n\n  try {\n    const refererUrl = new URL(referer);\n    return getSanitizedUrlStringFromUrlObject(refererUrl);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Returns a sanitized URL string using the referer header if available,\n * otherwise constructs the URL from the component route, params, and headers.\n *\n * @param componentRoute - The route template to construct the URL from\n * @param params - Optional route parameters to replace in the template\n * @param headersDict - Optional headers containing protocol, host, and referer\n * @param pathname - Optional pathname coming from root span \"http.target\"\n * @returns A sanitized URL string\n */\nexport function getSanitizedRequestUrl(\n  componentRoute: string,\n  params?: ComponentRouteParams,\n  headersDict?: HeadersDict,\n  pathname?: string,\n): string {\n  const refererUrl = extractSanitizedUrlFromRefererHeader(headersDict);\n  if (refererUrl) {\n    return refererUrl;\n  }\n\n  return buildUrlFromComponentRoute(componentRoute, params, headersDict, pathname);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAKA,MAAM,aAAa;IACjB,eAAe,EAAE,mBAAmB;IACpC,cAAc,EAAE,kBAAkB;IAClC,IAAI,EAAE,MAAM;IACZ,OAAO,EAAE,SAAS;AACpB,CAAA;AAEA;;;;;CAKA,GACO,SAAS,qBAAqB,CAAC,IAAI,EAAU,MAAM,EAAiC;IAC9C,OAAO,IAAI;AAOxD;AAEA;;;;CAIA,GACO,SAAS,iBAAiB,CAAC,IAAI,EAAkB;IACtD,MAAM,kBAAkB,KACrB,KAAK,CAAC,GAAG,EACT,MAAM,EAAC,OAAA,GAAW,OAAA,IAAW,CAAA,CAAE,OAAO,CAAC,UAAU,CAAC,GAAG,CAAA,IAAK,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;IAEpF,OAAO,eAAe,CAAC,MAAA,GAAS,IAAI,CAAC,CAAC,EAAE,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA,GAAA,GAAA;AACA;AAEA;;;;;;;;CAQA,GACA,SAAA,0BAAA,CACA,cAAA,EACA,MAAA,EACA,WAAA,EACA,QAAA;IAEA,MAAA,iBAAA,GAAA,qBAAA,CAAA,cAAA,CAAA;IACA,gIAAA;IACA,4GAAA;IACA,MAAA,IAAA,GAAA,QAAA,IAAA,iBAAA,CAAA,iBAAA,CAAA;IAEA,MAAA,QAAA,GAAA,WAAA,EAAA,CAAA,UAAA,CAAA,eAAA,CAAA;IACA,MAAA,IAAA,GAAA,WAAA,EAAA,CAAA,UAAA,CAAA,cAAA,CAAA,IAAA,WAAA,EAAA,CAAA,UAAA,CAAA,IAAA,CAAA;IAEA,IAAA,CAAA,QAAA,IAAA,CAAA,IAAA,EAAA;QACA,OAAA,IAAA;IACA;IAEA,MAAA,OAAA,GAAA,CAAA,EAAA,QAAA,CAAA,GAAA,EAAA,IAAA,CAAA,EAAA,IAAA,CAAA,CAAA;IAEA,MAAA,SAAA,OAAA,kMAAA,EAAA,OAAA,CAAA;IACA,IAAA,CAAA,SAAA,EAAA;QACA,OAAA,IAAA;IACA;IAEA,WAAA,8MAAA,EAAA,SAAA,CAAA;AACA;AAEA;;;;;CAKA,GACA,SAAA,oCAAA,CAAA,WAAA,EAAA;IACA,MAAA,OAAA,GAAA,WAAA,EAAA,CAAA,UAAA,CAAA,OAAA,CAAA;IACA,IAAA,CAAA,OAAA,EAAA;QACA,OAAA,SAAA;IACA;IAEA,IAAA;QACA,MAAA,UAAA,GAAA,IAAA,GAAA,CAAA,OAAA,CAAA;QACA,WAAA,8MAAA,EAAA,UAAA,CAAA;IACA,CAAA,CAAA,OAAA;QACA,OAAA,SAAA;IACA;AACA;AAEA;;;;;;;;;CASA,GACA,SAAA,sBAAA,CACA,cAAA,EACA,MAAA,EACA,WAAA,EACA,QAAA;IAEA,MAAA,UAAA,GAAA,oCAAA,CAAA,WAAA,CAAA;IACA,IAAA,UAAA,EAAA;QACA,OAAA,UAAA;IACA;IAEA,OAAA,0BAAA,CAAA,cAAA,EAAA,MAAA,EAAA,WAAA,EAAA,QAAA,CAAA;AACA"}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/setUrlProcessingMetadata.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/setUrlProcessingMetadata.ts"],"sourcesContent":["import type { Event } from '@sentry/core';\nimport { getClient } from '@sentry/core';\nimport { getSanitizedRequestUrl } from './urls';\n\n/**\n * Sets the URL processing metadata for the event.\n */\nexport function setUrlProcessingMetadata(event: Event): void {\n  // Skip if not a server-side transaction\n  if (event.type !== 'transaction' || event.contexts?.trace?.op !== 'http.server' || !event.contexts?.trace?.data) {\n    return;\n  }\n\n  // Only add URL if sendDefaultPii is enabled, as URLs may contain PII\n  const client = getClient();\n  if (!client?.getOptions().sendDefaultPii) {\n    return;\n  }\n\n  const traceData = event.contexts.trace.data;\n\n  // Get the route from trace data\n  const componentRoute = traceData['next.route'] || traceData['http.route'];\n  const httpTarget = traceData['http.target'] as string | undefined;\n\n  if (!componentRoute) {\n    return;\n  }\n\n  // Extract headers\n  const isolationScopeData = event.sdkProcessingMetadata?.capturedSpanIsolationScope?.getScopeData();\n  const headersDict = isolationScopeData?.sdkProcessingMetadata?.normalizedRequest?.headers;\n\n  const url = getSanitizedRequestUrl(componentRoute, undefined, headersDict, httpTarget?.toString());\n\n  // Add URL to the isolation scope's normalizedRequest so requestDataIntegration picks it up\n  if (url && isolationScopeData?.sdkProcessingMetadata) {\n    isolationScopeData.sdkProcessingMetadata.normalizedRequest =\n      isolationScopeData.sdkProcessingMetadata.normalizedRequest || {};\n    isolationScopeData.sdkProcessingMetadata.normalizedRequest.url = url;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAIA;;CAEA,GACO,SAAS,wBAAwB,CAAC,KAAK,EAAe;IAC7D,wCAAA;IACE,IAAI,KAAK,CAAC,IAAA,KAAS,aAAA,IAAiB,KAAK,CAAC,QAAQ,EAAE,KAAK,EAAE,EAAA,KAAO,aAAA,IAAiB,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE;QAC/G;IACF;IAEF,qEAAA;IACE,MAAM,MAAA,OAAS,sLAAS,EAAE;IAC1B,IAAI,CAAC,MAAM,EAAE,UAAU,EAAE,CAAC,cAAc,EAAE;QACxC;IACF;IAEA,MAAM,YAAY,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI;IAE7C,gCAAA;IACE,MAAM,cAAA,GAAiB,SAAS,CAAC,YAAY,CAAA,IAAK,SAAS,CAAC,YAAY,CAAC;IACzE,MAAM,UAAA,GAAa,SAAS,CAAC,aAAa,CAAA;IAE1C,IAAI,CAAC,cAAc,EAAE;QACnB;IACF;IAEF,kBAAA;IACE,MAAM,kBAAA,GAAqB,KAAK,CAAC,qBAAqB,EAAE,0BAA0B,EAAE,YAAY,EAAE;IAClG,MAAM,cAAc,kBAAkB,EAAE,qBAAqB,EAAE,iBAAiB,EAAE,OAAO;IAEzF,MAAM,GAAA,OAAM,+MAAsB,EAAC,cAAc,EAAE,SAAS,EAAE,WAAW,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC;IAEpG,2FAAA;IACE,IAAI,GAAA,IAAO,kBAAkB,EAAE,qBAAqB,EAAE;QACpD,kBAAkB,CAAC,qBAAqB,CAAC,iBAAA,GACvC,kBAAkB,CAAC,qBAAqB,CAAC,iBAAA,IAAqB,CAAA,CAAE;QAClE,kBAAkB,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,GAAA,GAAM,GAAG;IACtE;AACF"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/edge/distDirRewriteFramesIntegration.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/edge/distDirRewriteFramesIntegration.ts"],"sourcesContent":["import { defineIntegration, escapeStringForRegex, rewriteFramesIntegration } from '@sentry/core';\n\nexport const distDirRewriteFramesIntegration = defineIntegration(({ distDirName }: { distDirName: string }) => {\n  const distDirAbsPath = distDirName.replace(/(\\/|\\\\)$/, ''); // We strip trailing slashes because \"app:///_next\" also doesn't have one\n\n  // Normally we would use `path.resolve` to obtain the absolute path we will strip from the stack frame to align with\n  // the uploaded artifacts, however we don't have access to that API in edge so we need to be a bit more lax.\n  // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- user input is escaped\n  const SOURCEMAP_FILENAME_REGEX = new RegExp(`.*${escapeStringForRegex(distDirAbsPath)}`);\n\n  const rewriteFramesIntegrationInstance = rewriteFramesIntegration({\n    iteratee: frame => {\n      frame.filename = frame.filename?.replace(SOURCEMAP_FILENAME_REGEX, 'app:///_next');\n      return frame;\n    },\n  });\n\n  return {\n    ...rewriteFramesIntegrationInstance,\n    name: 'DistDirRewriteFrames',\n  };\n});\n"],"names":[],"mappings":";;;;;;;;AAEO,MAAM,+BAAA,OAAkC,4LAAiB,EAAC,CAAC,EAAE,WAAA,EAAa,KAA8B;IAC7G,MAAM,cAAA,GAAiB,WAAW,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAA,CAAA,yEAAA;IAE5D,oHAAA;IACA,4GAAA;IACA,+FAAA;IACE,MAAM,wBAAA,GAA2B,IAAI,MAAM,CAAC,CAAC,EAAE,MAAE,kNAAoB,EAAC,cAAc,CAAC,CAAC,CAAA,CAAA;IAEA,MAAA,gCAAA,OAAA,qNAAA,EAAA;QACA,QAAA,GAAA,KAAA,IAAA;YACA,KAAA,CAAA,QAAA,GAAA,KAAA,CAAA,QAAA,EAAA,OAAA,CAAA,wBAAA,EAAA,cAAA,CAAA;YACA,OAAA,KAAA;QACA,CAAA;IACA,CAAA,CAAA;IAEA,OAAA;QACA,GAAA,gCAAA;QACA,IAAA,EAAA,sBAAA;IACA,CAAA;AACA,CAAA"}},
    {"offset": {"line": 394, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/edge/index.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/edge/index.ts"],"sourcesContent":["// import/export got a false positive, and affects most of our index barrel files\n// can be removed once following issue is fixed: https://github.com/import-js/eslint-plugin-import/issues/703\n/* eslint-disable import/export */\nimport { context } from '@opentelemetry/api';\nimport {\n  applySdkMetadata,\n  type EventProcessor,\n  getCapturedScopesOnSpan,\n  getCurrentScope,\n  getGlobalScope,\n  getIsolationScope,\n  getRootSpan,\n  GLOBAL_OBJ,\n  registerSpanErrorInstrumentation,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setCapturedScopesOnSpan,\n  spanToJSON,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport { getScopesFromContext } from '@sentry/opentelemetry';\nimport type { VercelEdgeOptions } from '@sentry/vercel-edge';\nimport { getDefaultIntegrations, init as vercelEdgeInit } from '@sentry/vercel-edge';\nimport { TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION } from '../common/span-attributes-with-logic-attached';\nimport { addHeadersAsAttributes } from '../common/utils/addHeadersAsAttributes';\nimport { dropMiddlewareTunnelRequests } from '../common/utils/dropMiddlewareTunnelRequests';\nimport { isBuild } from '../common/utils/isBuild';\nimport { flushSafelyWithTimeout, waitUntil } from '../common/utils/responseEnd';\nimport { setUrlProcessingMetadata } from '../common/utils/setUrlProcessingMetadata';\nimport { distDirRewriteFramesIntegration } from './distDirRewriteFramesIntegration';\n\nexport * from '@sentry/vercel-edge';\nexport * from '../common';\nexport { captureUnderscoreErrorException } from '../common/pages-router-instrumentation/_error';\n\n// Override core span methods with Next.js-specific implementations that support Cache Components\nexport { startSpan, startSpanManual, startInactiveSpan } from '../common/utils/nextSpan';\nexport { wrapApiHandlerWithSentry } from './wrapApiHandlerWithSentry';\n\nexport type EdgeOptions = VercelEdgeOptions;\n\nconst globalWithInjectedValues = GLOBAL_OBJ as typeof GLOBAL_OBJ & {\n  _sentryRewriteFramesDistDir?: string;\n  _sentryRelease?: string;\n  _sentryRewritesTunnelPath?: string;\n};\n\n/** Inits the Sentry NextJS SDK on the Edge Runtime. */\nexport function init(options: VercelEdgeOptions = {}): void {\n  registerSpanErrorInstrumentation();\n\n  if (isBuild()) {\n    return;\n  }\n\n  const customDefaultIntegrations = getDefaultIntegrations(options);\n\n  // This value is injected at build time, based on the output directory specified in the build config. Though a default\n  // is set there, we set it here as well, just in case something has gone wrong with the injection.\n  const distDirName = process.env._sentryRewriteFramesDistDir || globalWithInjectedValues._sentryRewriteFramesDistDir;\n\n  if (distDirName) {\n    customDefaultIntegrations.push(distDirRewriteFramesIntegration({ distDirName }));\n  }\n\n  const opts = {\n    defaultIntegrations: customDefaultIntegrations,\n    release: process.env._sentryRelease || globalWithInjectedValues._sentryRelease,\n    ...options,\n  };\n\n  applySdkMetadata(opts, 'nextjs', ['nextjs', 'vercel-edge']);\n\n  const client = vercelEdgeInit(opts);\n\n  client?.on('spanStart', span => {\n    const spanAttributes = spanToJSON(span).data;\n    const rootSpan = getRootSpan(span);\n    const isRootSpan = span === rootSpan;\n\n    dropMiddlewareTunnelRequests(span, spanAttributes);\n\n    // Mark all spans generated by Next.js as 'auto'\n    if (spanAttributes?.['next.span_type'] !== undefined) {\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto');\n    }\n\n    // Make sure middleware spans get the right op\n    if (spanAttributes?.['next.span_type'] === 'Middleware.execute') {\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'http.server.middleware');\n      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'url');\n\n      if (isRootSpan) {\n        // Fork isolation scope for middleware requests\n        const scopes = getCapturedScopesOnSpan(span);\n        const isolationScope = (scopes.isolationScope || getIsolationScope()).clone();\n        const scope = scopes.scope || getCurrentScope();\n        const currentScopesPointer = getScopesFromContext(context.active());\n        if (currentScopesPointer) {\n          currentScopesPointer.isolationScope = isolationScope;\n        }\n\n        setCapturedScopesOnSpan(span, scope, isolationScope);\n      }\n    }\n\n    if (isRootSpan) {\n      // todo: check if we can set request headers for edge on sdkProcessingMetadata\n      const headers = getIsolationScope().getScopeData().sdkProcessingMetadata?.normalizedRequest?.headers;\n      addHeadersAsAttributes(headers, rootSpan);\n    }\n  });\n\n  // Use the preprocessEvent hook instead of an event processor, so that the users event processors receive the most\n  // up-to-date value, but also so that the logic that detects changes to the transaction names to set the source to\n  // \"custom\", doesn't trigger.\n  client?.on('preprocessEvent', event => {\n    // The otel auto inference will clobber the transaction name because the span has an http.target\n    if (\n      event.type === 'transaction' &&\n      event.contexts?.trace?.data?.['next.span_type'] === 'Middleware.execute' &&\n      event.contexts?.trace?.data?.['next.span_name']\n    ) {\n      if (event.transaction) {\n        // Older nextjs versions pass the full url appended to the middleware name, which results in high cardinality transaction names.\n        // We want to remove the url from the name here.\n        const spanName = event.contexts.trace.data['next.span_name'];\n\n        if (typeof spanName === 'string') {\n          const match = spanName.match(/^middleware (GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)/);\n          if (match) {\n            const normalizedName = `middleware ${match[1]}`;\n            event.transaction = normalizedName;\n          } else {\n            event.transaction = stripUrlQueryAndFragment(event.contexts.trace.data['next.span_name']);\n          }\n        }\n      }\n    }\n\n    setUrlProcessingMetadata(event);\n  });\n\n  client?.on('spanEnd', span => {\n    if (span === getRootSpan(span)) {\n      waitUntil(flushSafelyWithTimeout());\n    }\n  });\n\n  getGlobalScope().addEventProcessor(\n    Object.assign(\n      (event => {\n        // Filter transactions that we explicitly want to drop.\n        if (event.type === 'transaction') {\n          if (event.contexts?.trace?.data?.[TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION]) {\n            return null;\n          }\n\n          return event;\n        } else {\n          return event;\n        }\n      }) satisfies EventProcessor,\n      { id: 'NextLowQualityTransactionsFilter' },\n    ),\n  );\n\n  try {\n    // @ts-expect-error `process.turbopack` is a magic string that will be replaced by Next.js\n    if (process.turbopack) {\n      getGlobalScope().setTag('turbopack', true);\n    }\n  } catch {\n    // Noop\n    // The statement above can throw because process is not defined on the client\n  }\n}\n\n/**\n * Just a passthrough in case this is imported from the client.\n */\nexport function withSentryConfig<T>(exportedUserNextConfig: T): T {\n  return exportedUserNextConfig;\n}\n"],"names":["vercelEdgeInit"],"mappings":"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"}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/wrapperUtils.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/wrapperUtils.ts"],"sourcesContent":["import {\n  captureException,\n  getActiveSpan,\n  getCurrentScope,\n  getIsolationScope,\n  getRootSpan,\n  getTraceData,\n  httpRequestToRequestData,\n  isThenable,\n} from '@sentry/core';\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport { TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL } from '../span-attributes-with-logic-attached';\n\n/**\n * Wraps a function that potentially throws. If it does, the error is passed to `captureException` and rethrown.\n *\n * Note: This function turns the wrapped function into an asynchronous one.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withErrorInstrumentation<F extends (...args: any[]) => any>(\n  origFunction: F,\n): (...params: Parameters<F>) => Promise<ReturnType<F>> {\n  return async function (this: unknown, ...origFunctionArguments: Parameters<F>): Promise<ReturnType<F>> {\n    try {\n      return await origFunction.apply(this, origFunctionArguments);\n    } catch (e) {\n      // TODO: Extract error logic from `withSentry` in here or create a new wrapper with said logic or something like that.\n      captureException(e, {\n        // TODO: check if origFunction.name actually returns the correct name or minified garbage\n        // in this case, we can add another argument to this wrapper with the respective function name\n        mechanism: { handled: false, type: 'auto.function.nextjs.wrapped', data: { function: origFunction.name } },\n      });\n      throw e;\n    }\n  };\n}\n\n/**\n * Calls a server-side data fetching function (that takes a `req` and `res` object in its context) with tracing\n * instrumentation. A transaction will be created for the incoming request (if it doesn't already exist) in addition to\n * a span for the wrapped data fetching function.\n *\n * All of the above happens in an isolated domain, meaning all thrown errors will be associated with the correct span.\n *\n * @param origDataFetcher The data fetching method to call.\n * @param origFunctionArguments The arguments to call the data fetching method with.\n * @param req The data fetching function's request object.\n * @param res The data fetching function's response object.\n * @param options Options providing details for the created transaction and span.\n * @returns what the data fetching method call returned.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withTracedServerSideDataFetcher<F extends (...args: any[]) => Promise<any> | any>(\n  origDataFetcher: F,\n  req: IncomingMessage,\n  res: ServerResponse,\n  options: {\n    /** Parameterized route of the request - will be used for naming the transaction. */\n    requestedRouteName: string;\n    /** Name of the route the data fetcher was defined in - will be used for describing the data fetcher's span. */\n    dataFetcherRouteName: string;\n    /** Name of the data fetching method - will be used for describing the data fetcher's span. */\n    dataFetchingMethodName: string;\n  },\n): (...params: Parameters<F>) => Promise<{ data: ReturnType<F>; sentryTrace?: string; baggage?: string }> {\n  return async function (\n    this: unknown,\n    ...args: Parameters<F>\n  ): Promise<{ data: ReturnType<F>; sentryTrace?: string; baggage?: string }> {\n    const normalizedRequest = httpRequestToRequestData(req);\n    getCurrentScope().setTransactionName(`${options.dataFetchingMethodName} (${options.dataFetcherRouteName})`);\n    getIsolationScope().setSDKProcessingMetadata({ normalizedRequest });\n\n    const span = getActiveSpan();\n\n    // Only set the route backfill if the span is not for /_error\n    if (span && options.requestedRouteName !== '/_error') {\n      const root = getRootSpan(span);\n      root.setAttribute(TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL, options.requestedRouteName);\n    }\n\n    const { 'sentry-trace': sentryTrace, baggage } = getTraceData();\n\n    return {\n      sentryTrace: sentryTrace,\n      baggage: baggage,\n      data: await origDataFetcher.apply(this, args),\n    };\n  };\n}\n\n/**\n * Call a data fetcher and trace it. Only traces the function if there is an active transaction on the scope.\n *\n * We only do the following until we move transaction creation into this function: When called, the wrapped function\n * will also update the name of the active transaction with a parameterized route provided via the `options` argument.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function callDataFetcherTraced<F extends (...args: any[]) => Promise<any> | any>(\n  origFunction: F,\n  origFunctionArgs: Parameters<F>,\n): Promise<ReturnType<F>> {\n  try {\n    return await origFunction(...origFunctionArgs);\n  } catch (e) {\n    captureException(e, { mechanism: { handled: false, type: 'auto.function.nextjs.data_fetcher' } });\n    throw e;\n  }\n}\n\n/**\n * Extracts the params and searchParams from the props object.\n *\n * Depending on the next version, params and searchParams may be a promise which we do not want to resolve in this function.\n */\nexport function maybeExtractSynchronousParamsAndSearchParams(props: unknown): {\n  params: Record<string, string> | undefined;\n  searchParams: Record<string, string> | undefined;\n} {\n  let params =\n    props && typeof props === 'object' && 'params' in props\n      ? (props.params as Record<string, string> | Promise<Record<string, string>> | undefined)\n      : undefined;\n  if (isThenable(params)) {\n    params = undefined;\n  }\n\n  let searchParams =\n    props && typeof props === 'object' && 'searchParams' in props\n      ? (props.searchParams as Record<string, string> | Promise<Record<string, string>> | undefined)\n      : undefined;\n  if (isThenable(searchParams)) {\n    searchParams = undefined;\n  }\n\n  return { params, searchParams };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAaA;;;;CAIA,GACA,8DAAA;AACO,SAAS,wBAAwB,CACtC,YAAY;IAEZ,OAAO,eAA+B,GAAG,qBAAqB,EAAyC;QACrG,IAAI;YACF,OAAO,MAAM,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,qBAAqB,CAAC;QAC9D,CAAA,CAAE,OAAO,CAAC,EAAE;YAChB,sHAAA;gBACM,uLAAgB,EAAC,CAAC,EAAE;gBAC1B,yFAAA;gBACA,8FAAA;gBACQ,SAAS,EAAE;oBAAE,OAAO,EAAE,KAAK;oBAAE,IAAI,EAAE,8BAA8B;oBAAE,IAAI,EAAE;wBAAE,QAAQ,EAAE,YAAY,CAAC,IAAA;oBAAA;gBAAA,CAAQ;YAClH,CAAO,CAAC;YACF,MAAM,CAAC;QACT;IACF,CAAC;AACH;AAEA;;;;;;;;;;;;;CAaA,GACA,8DAAA;AACO,SAAS,+BAA+B,CAC7C,eAAe,EACf,GAAG,EACH,GAAG,EACH,OAAA;IASA,OAAO,eAEL,GAAG,IAAA;QAEH,MAAM,iBAAA,OAAoB,wMAAwB,EAAC,GAAG,CAAC;YACvD,4LAAe,EAAE,EAAC,kBAAkB,CAAC,CAAC,EAAA,OAAA,CAAA,sBAAA,CAAA,EAAA,EAAA,OAAA,CAAA,oBAAA,CAAA,CAAA,CAAA,CAAA;YACA,8LAAA,EAAA,EAAA,wBAAA,CAAA;YAAA,iBAAA;QAAA,CAAA,CAAA;QAEA,MAAA,IAAA,OAAA,+LAAA,EAAA;QAEA,6DAAA;QACA,IAAA,IAAA,IAAA,OAAA,CAAA,kBAAA,KAAA,SAAA,EAAA;YACA,MAAA,IAAA,OAAA,6LAAA,EAAA,IAAA,CAAA;YACA,IAAA,CAAA,YAAA,CAAA,iQAAA,EAAA,OAAA,CAAA,kBAAA,CAAA;QACA;QAEA,MAAA,EAAA,cAAA,EAAA,WAAA,EAAA,OAAA,EAAA,OAAA,8LAAA,EAAA;QAEA,OAAA;YACA,WAAA,EAAA,WAAA;YACA,OAAA,EAAA,OAAA;YACA,IAAA,EAAA,MAAA,eAAA,CAAA,KAAA,CAAA,IAAA,EAAA,IAAA,CAAA;QACA,CAAA;IACA,CAAA;AACA;AAEA;;;;;CAKA,GACA,8DAAA;AACA,eAAA,qBAAA,CACA,YAAA,EACA,gBAAA;IAEA,IAAA;QACA,OAAA,MAAA,YAAA,CAAA,GAAA,gBAAA,CAAA;IACA,CAAA,CAAA,OAAA,CAAA,EAAA;YACA,uLAAA,EAAA,CAAA,EAAA;YAAA,SAAA,EAAA;gBAAA,OAAA,EAAA,KAAA;gBAAA,IAAA,EAAA,mCAAA;YAAA,CAAA;QAAA,CAAA,CAAA;QACA,MAAA,CAAA;IACA;AACA"}},
    {"offset": {"line": 669, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapGetStaticPropsWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapGetStaticPropsWithSentry.ts"],"sourcesContent":["import type { GetStaticProps } from 'next';\nimport { isBuild } from '../utils/isBuild';\nimport { callDataFetcherTraced, withErrorInstrumentation } from '../utils/wrapperUtils';\n\ntype Props = { [key: string]: unknown };\n\n/**\n * Create a wrapped version of the user's exported `getStaticProps` function\n *\n * @param origGetStaticProps The user's `getStaticProps` function\n * @param parameterizedRoute The page's parameterized route\n * @returns A wrapped version of the function\n */\nexport function wrapGetStaticPropsWithSentry(\n  origGetStaticPropsa: GetStaticProps<Props>,\n  _parameterizedRoute: string,\n): GetStaticProps<Props> {\n  return new Proxy(origGetStaticPropsa, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<GetStaticProps<Props>>) => {\n      if (isBuild()) {\n        return wrappingTarget.apply(thisArg, args);\n      }\n\n      const errorWrappedGetStaticProps = withErrorInstrumentation(wrappingTarget);\n      return callDataFetcherTraced(errorWrappedGetStaticProps, args);\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAMA;;;;;;CAMA,GACO,SAAS,4BAA4B,CAC1C,mBAAmB,EACnB,mBAAmB;IAEnB,OAAO,IAAI,KAAK,CAAC,mBAAmB,EAAE;QACpC,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAAwC;YACjF,QAAI,mMAAO,EAAE,GAAE;gBACb,OAAO,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YAC5C;YAEA,MAAM,0BAAA,OAA6B,yNAAwB,EAAC,cAAc,CAAC;YAC3E,WAAO,sNAAqB,EAAC,0BAA0B,EAAE,IAAI,CAAC;QAChE,CAAC;IACL,CAAG,CAAC;AACJ"}},
    {"offset": {"line": 700, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapGetInitialPropsWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapGetInitialPropsWithSentry.ts"],"sourcesContent":["import type { NextPage } from 'next';\nimport { isBuild } from '../utils/isBuild';\nimport { withErrorInstrumentation, withTracedServerSideDataFetcher } from '../utils/wrapperUtils';\n\ntype GetInitialProps = Required<NextPage>['getInitialProps'];\n\n/**\n * Create a wrapped version of the user's exported `getInitialProps` function\n *\n * @param origGetInitialProps The user's `getInitialProps` function\n * @param parameterizedRoute The page's parameterized route\n * @returns A wrapped version of the function\n */\nexport function wrapGetInitialPropsWithSentry(origGetInitialProps: GetInitialProps): GetInitialProps {\n  return new Proxy(origGetInitialProps, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<GetInitialProps>) => {\n      if (isBuild()) {\n        return wrappingTarget.apply(thisArg, args);\n      }\n\n      const [context] = args;\n      const { req, res } = context;\n\n      const errorWrappedGetInitialProps = withErrorInstrumentation(wrappingTarget);\n      // Generally we can assume that `req` and `res` are always defined on the server:\n      // https://nextjs.org/docs/api-reference/data-fetching/get-initial-props#context-object\n      // This does not seem to be the case in dev mode. Because we have no clean way of associating the the data fetcher\n      // span with each other when there are no req or res objects, we simply do not trace them at all here.\n      if (req && res) {\n        const tracedGetInitialProps = withTracedServerSideDataFetcher(errorWrappedGetInitialProps, req, res, {\n          dataFetcherRouteName: context.pathname,\n          requestedRouteName: context.pathname,\n          dataFetchingMethodName: 'getInitialProps',\n        });\n\n        const {\n          data: initialProps,\n          baggage,\n          sentryTrace,\n        }: {\n          data?: unknown;\n          baggage?: string;\n          sentryTrace?: string;\n        } = (await tracedGetInitialProps.apply(thisArg, args)) ?? {}; // Next.js allows undefined to be returned from a getInitialPropsFunction.\n\n        if (typeof initialProps === 'object' && initialProps !== null) {\n          // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n          if (sentryTrace) {\n            (initialProps as Record<string, unknown>)._sentryTraceData = sentryTrace;\n          }\n\n          // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n          if (baggage) {\n            (initialProps as Record<string, unknown>)._sentryBaggage = baggage;\n          }\n        }\n\n        return initialProps;\n      } else {\n        return errorWrappedGetInitialProps.apply(thisArg, args);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAMA;;;;;;CAMA,GACO,SAAS,6BAA6B,CAAC,mBAAmB,EAAoC;IACnG,OAAO,IAAI,KAAK,CAAC,mBAAmB,EAAE;QACpC,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAAkC;YAC3E,QAAI,mMAAO,EAAE,GAAE;gBACb,OAAO,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YAC5C;YAEA,MAAM,CAAC,OAAO,CAAA,GAAI,IAAI;YACtB,MAAM,EAAE,GAAG,EAAE,GAAA,EAAI,GAAI,OAAO;YAE5B,MAAM,2BAAA,OAA8B,yNAAwB,EAAC,cAAc,CAAC;YAClF,iFAAA;YACA,uFAAA;YACA,kHAAA;YACA,sGAAA;YACM,IAAI,GAAA,IAAO,GAAG,EAAE;gBACd,MAAM,qBAAA,OAAwB,gOAA+B,EAAC,2BAA2B,EAAE,GAAG,EAAE,GAAG,EAAE;oBACnG,oBAAoB,EAAE,OAAO,CAAC,QAAQ;oBACtC,kBAAkB,EAAE,OAAO,CAAC,QAAQ;oBACpC,sBAAsB,EAAE,iBAAiB;gBACnD,CAAS,CAAC;gBAEF,MAAM,EACJ,IAAI,EAAE,YAAY,EAClB,OAAO,EACP,WAAW,EACrB,GAIY,AAAC,MAAM,qBAAqB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,IAAK,CAAA,CAAE,CAAA,CAAA,0EAAA;gBAE5D,IAAI,OAAO,YAAA,KAAiB,YAAY,YAAA,KAAiB,IAAI,EAAE;oBACvE,wFAAA;oBACU,IAAI,WAAW,EAAE;wBACd,YAAA,CAAyC,gBAAA,GAAmB,WAAW;oBAC1E;oBAEV,wFAAA;oBACU,IAAI,OAAO,EAAE;wBACV,YAAA,CAAyC,cAAA,GAAiB,OAAO;oBACpE;gBACF;gBAEA,OAAO,YAAY;YACrB,OAAO;gBACL,OAAO,2BAA2B,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YACzD;QACF,CAAC;IACL,CAAG,CAAC;AACJ"}},
    {"offset": {"line": 757, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapAppGetInitialPropsWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapAppGetInitialPropsWithSentry.ts"],"sourcesContent":["import type App from 'next/app';\nimport { isBuild } from '../utils/isBuild';\nimport { withErrorInstrumentation, withTracedServerSideDataFetcher } from '../utils/wrapperUtils';\n\ntype AppGetInitialProps = (typeof App)['getInitialProps'];\n\n/**\n * Create a wrapped version of the user's exported `getInitialProps` function in\n * a custom app (\"_app.js\").\n *\n * @param origAppGetInitialProps The user's `getInitialProps` function\n * @param parameterizedRoute The page's parameterized route\n * @returns A wrapped version of the function\n */\nexport function wrapAppGetInitialPropsWithSentry(origAppGetInitialProps: AppGetInitialProps): AppGetInitialProps {\n  return new Proxy(origAppGetInitialProps, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<AppGetInitialProps>) => {\n      if (isBuild()) {\n        return wrappingTarget.apply(thisArg, args);\n      }\n\n      const [context] = args;\n      const { req, res } = context.ctx;\n\n      const errorWrappedAppGetInitialProps = withErrorInstrumentation(wrappingTarget);\n\n      // Generally we can assume that `req` and `res` are always defined on the server:\n      // https://nextjs.org/docs/api-reference/data-fetching/get-initial-props#context-object\n      // This does not seem to be the case in dev mode. Because we have no clean way of associating the the data fetcher\n      // span with each other when there are no req or res objects, we simply do not trace them at all here.\n      if (req && res) {\n        const tracedGetInitialProps = withTracedServerSideDataFetcher(errorWrappedAppGetInitialProps, req, res, {\n          dataFetcherRouteName: '/_app',\n          requestedRouteName: context.ctx.pathname,\n          dataFetchingMethodName: 'getInitialProps',\n        });\n\n        const {\n          data: appGetInitialProps,\n          sentryTrace,\n          baggage,\n        }: {\n          data?: unknown;\n          sentryTrace?: string;\n          baggage?: string;\n        } = await tracedGetInitialProps.apply(thisArg, args);\n\n        if (typeof appGetInitialProps === 'object' && appGetInitialProps !== null) {\n          // Per definition, `pageProps` is not optional, however an increased amount of users doesn't seem to call\n          // `App.getInitialProps(appContext)` in their custom `_app` pages which is required as per\n          // https://nextjs.org/docs/advanced-features/custom-app - resulting in missing `pageProps`.\n          // For this reason, we just handle the case where `pageProps` doesn't exist explicitly.\n          if (!(appGetInitialProps as Record<string, unknown>).pageProps) {\n            (appGetInitialProps as Record<string, unknown>).pageProps = {};\n          }\n\n          // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n          if (sentryTrace) {\n            (appGetInitialProps as { pageProps: Record<string, unknown> }).pageProps._sentryTraceData = sentryTrace;\n          }\n\n          // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n          if (baggage) {\n            (appGetInitialProps as { pageProps: Record<string, unknown> }).pageProps._sentryBaggage = baggage;\n          }\n        }\n\n        return appGetInitialProps;\n      } else {\n        return errorWrappedAppGetInitialProps.apply(thisArg, args);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAMA;;;;;;;CAOA,GACO,SAAS,gCAAgC,CAAC,sBAAsB,EAA0C;IAC/G,OAAO,IAAI,KAAK,CAAC,sBAAsB,EAAE;QACvC,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAAqC;YAC9E,QAAI,mMAAO,EAAE,GAAE;gBACb,OAAO,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YAC5C;YAEA,MAAM,CAAC,OAAO,CAAA,GAAI,IAAI;YACtB,MAAM,EAAE,GAAG,EAAE,GAAA,EAAI,GAAI,OAAO,CAAC,GAAG;YAEhC,MAAM,8BAAA,OAAiC,yNAAwB,EAAC,cAAc,CAAC;YAErF,iFAAA;YACA,uFAAA;YACA,kHAAA;YACA,sGAAA;YACM,IAAI,GAAA,IAAO,GAAG,EAAE;gBACd,MAAM,qBAAA,OAAwB,gOAA+B,EAAC,8BAA8B,EAAE,GAAG,EAAE,GAAG,EAAE;oBACtG,oBAAoB,EAAE,OAAO;oBAC7B,kBAAkB,EAAE,OAAO,CAAC,GAAG,CAAC,QAAQ;oBACxC,sBAAsB,EAAE,iBAAiB;gBACnD,CAAS,CAAC;gBAEF,MAAM,EACJ,IAAI,EAAE,kBAAkB,EACxB,WAAW,EACX,OAAO,EACjB,GAIY,MAAM,qBAAqB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;gBAEpD,IAAI,OAAO,kBAAA,KAAuB,YAAY,kBAAA,KAAuB,IAAI,EAAE;oBACnF,yGAAA;oBACA,0FAAA;oBACA,2FAAA;oBACA,uFAAA;oBACU,IAAI,CAAC,AAAC,mBAA+C,SAAS,EAAE;wBAC7D,kBAAA,CAA+C,SAAA,GAAY,CAAA,CAAE;oBAChE;oBAEV,wFAAA;oBACU,IAAI,WAAW,EAAE;wBACd,mBAA8D,SAAS,CAAC,gBAAA,GAAmB,WAAW;oBACzG;oBAEV,wFAAA;oBACU,IAAI,OAAO,EAAE;wBACV,mBAA8D,SAAS,CAAC,cAAA,GAAiB,OAAO;oBACnG;gBACF;gBAEA,OAAO,kBAAkB;YAC3B,OAAO;gBACL,OAAO,8BAA8B,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YAC5D;QACF,CAAC;IACL,CAAG,CAAC;AACJ"}},
    {"offset": {"line": 822, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapDocumentGetInitialPropsWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapDocumentGetInitialPropsWithSentry.ts"],"sourcesContent":["import type Document from 'next/document';\nimport { isBuild } from '../utils/isBuild';\nimport { withErrorInstrumentation, withTracedServerSideDataFetcher } from '../utils/wrapperUtils';\n\ntype DocumentGetInitialProps = typeof Document.getInitialProps;\n\n/**\n * Create a wrapped version of the user's exported `getInitialProps` function in\n * a custom document (\"_document.js\").\n *\n * @param origDocumentGetInitialProps The user's `getInitialProps` function\n * @param parameterizedRoute The page's parameterized route\n * @returns A wrapped version of the function\n */\nexport function wrapDocumentGetInitialPropsWithSentry(\n  origDocumentGetInitialProps: DocumentGetInitialProps,\n): DocumentGetInitialProps {\n  return new Proxy(origDocumentGetInitialProps, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<DocumentGetInitialProps>) => {\n      if (isBuild()) {\n        return wrappingTarget.apply(thisArg, args);\n      }\n\n      const [context] = args;\n      const { req, res } = context;\n\n      const errorWrappedGetInitialProps = withErrorInstrumentation(wrappingTarget);\n      // Generally we can assume that `req` and `res` are always defined on the server:\n      // https://nextjs.org/docs/api-reference/data-fetching/get-initial-props#context-object\n      // This does not seem to be the case in dev mode. Because we have no clean way of associating the the data fetcher\n      // span with each other when there are no req or res objects, we simply do not trace them at all here.\n      if (req && res) {\n        const tracedGetInitialProps = withTracedServerSideDataFetcher(errorWrappedGetInitialProps, req, res, {\n          dataFetcherRouteName: '/_document',\n          requestedRouteName: context.pathname,\n          dataFetchingMethodName: 'getInitialProps',\n        });\n\n        const { data } = await tracedGetInitialProps.apply(thisArg, args);\n        return data;\n      } else {\n        return errorWrappedGetInitialProps.apply(thisArg, args);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAMA;;;;;;;CAOA,GACO,SAAS,qCAAqC,CACnD,2BAA2B;IAE3B,OAAO,IAAI,KAAK,CAAC,2BAA2B,EAAE;QAC5C,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAA0C;YACnF,QAAI,mMAAO,EAAE,GAAE;gBACb,OAAO,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YAC5C;YAEA,MAAM,CAAC,OAAO,CAAA,GAAI,IAAI;YACtB,MAAM,EAAE,GAAG,EAAE,GAAA,EAAI,GAAI,OAAO;YAE5B,MAAM,2BAAA,OAA8B,yNAAwB,EAAC,cAAc,CAAC;YAClF,iFAAA;YACA,uFAAA;YACA,kHAAA;YACA,sGAAA;YACM,IAAI,GAAA,IAAO,GAAG,EAAE;gBACd,MAAM,qBAAA,OAAwB,gOAA+B,EAAC,2BAA2B,EAAE,GAAG,EAAE,GAAG,EAAE;oBACnG,oBAAoB,EAAE,YAAY;oBAClC,kBAAkB,EAAE,OAAO,CAAC,QAAQ;oBACpC,sBAAsB,EAAE,iBAAiB;gBACnD,CAAS,CAAC;gBAEF,MAAM,EAAE,IAAA,EAAK,GAAI,MAAM,qBAAqB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;gBACjE,OAAO,IAAI;YACb,OAAO;gBACL,OAAO,2BAA2B,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YACzD;QACF,CAAC;IACL,CAAG,CAAC;AACJ"}},
    {"offset": {"line": 870, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapErrorGetInitialPropsWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapErrorGetInitialPropsWithSentry.ts"],"sourcesContent":["import type { NextPageContext } from 'next';\nimport type { ErrorProps } from 'next/error';\nimport { isBuild } from '../utils/isBuild';\nimport { withErrorInstrumentation, withTracedServerSideDataFetcher } from '../utils/wrapperUtils';\n\ntype ErrorGetInitialProps = (context: NextPageContext) => Promise<ErrorProps>;\n\n/**\n * Create a wrapped version of the user's exported `getInitialProps` function in\n * a custom error page (\"_error.js\").\n *\n * @param origErrorGetInitialProps The user's `getInitialProps` function\n * @param parameterizedRoute The page's parameterized route\n * @returns A wrapped version of the function\n */\nexport function wrapErrorGetInitialPropsWithSentry(\n  origErrorGetInitialProps: ErrorGetInitialProps,\n): ErrorGetInitialProps {\n  return new Proxy(origErrorGetInitialProps, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<ErrorGetInitialProps>) => {\n      if (isBuild()) {\n        return wrappingTarget.apply(thisArg, args);\n      }\n\n      const [context] = args;\n      const { req, res } = context;\n\n      const errorWrappedGetInitialProps = withErrorInstrumentation(wrappingTarget);\n      // Generally we can assume that `req` and `res` are always defined on the server:\n      // https://nextjs.org/docs/api-reference/data-fetching/get-initial-props#context-object\n      // This does not seem to be the case in dev mode. Because we have no clean way of associating the the data fetcher\n      // span with each other when there are no req or res objects, we simply do not trace them at all here.\n      if (req && res) {\n        const tracedGetInitialProps = withTracedServerSideDataFetcher(errorWrappedGetInitialProps, req, res, {\n          dataFetcherRouteName: '/_error',\n          requestedRouteName: context.pathname,\n          dataFetchingMethodName: 'getInitialProps',\n        });\n\n        const {\n          data: errorGetInitialProps,\n          baggage,\n          sentryTrace,\n        }: {\n          data?: unknown;\n          baggage?: string;\n          sentryTrace?: string;\n        } = await tracedGetInitialProps.apply(thisArg, args);\n\n        if (typeof errorGetInitialProps === 'object' && errorGetInitialProps !== null) {\n          if (sentryTrace) {\n            // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n            (errorGetInitialProps as Record<string, unknown>)._sentryTraceData = sentryTrace;\n          }\n\n          // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n          if (baggage) {\n            (errorGetInitialProps as Record<string, unknown>)._sentryBaggage = baggage;\n          }\n        }\n\n        return errorGetInitialProps;\n      } else {\n        return errorWrappedGetInitialProps.apply(thisArg, args);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAOA;;;;;;;CAOA,GACO,SAAS,kCAAkC,CAChD,wBAAwB;IAExB,OAAO,IAAI,KAAK,CAAC,wBAAwB,EAAE;QACzC,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAAuC;YAChF,QAAI,mMAAO,EAAE,GAAE;gBACb,OAAO,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YAC5C;YAEA,MAAM,CAAC,OAAO,CAAA,GAAI,IAAI;YACtB,MAAM,EAAE,GAAG,EAAE,GAAA,EAAI,GAAI,OAAO;YAE5B,MAAM,2BAAA,OAA8B,yNAAwB,EAAC,cAAc,CAAC;YAClF,iFAAA;YACA,uFAAA;YACA,kHAAA;YACA,sGAAA;YACM,IAAI,GAAA,IAAO,GAAG,EAAE;gBACd,MAAM,qBAAA,OAAwB,gOAA+B,EAAC,2BAA2B,EAAE,GAAG,EAAE,GAAG,EAAE;oBACnG,oBAAoB,EAAE,SAAS;oBAC/B,kBAAkB,EAAE,OAAO,CAAC,QAAQ;oBACpC,sBAAsB,EAAE,iBAAiB;gBACnD,CAAS,CAAC;gBAEF,MAAM,EACJ,IAAI,EAAE,oBAAoB,EAC1B,OAAO,EACP,WAAW,EACrB,GAIY,MAAM,qBAAqB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;gBAEpD,IAAI,OAAO,oBAAA,KAAyB,YAAY,oBAAA,KAAyB,IAAI,EAAE;oBAC7E,IAAI,WAAW,EAAE;wBAC3B,wFAAA;wBACa,oBAAA,CAAiD,gBAAA,GAAmB,WAAW;oBAClF;oBAEV,wFAAA;oBACU,IAAI,OAAO,EAAE;wBACV,oBAAA,CAAiD,cAAA,GAAiB,OAAO;oBAC5E;gBACF;gBAEA,OAAO,oBAAoB;YAC7B,OAAO;gBACL,OAAO,2BAA2B,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YACzD;QACF,CAAC;IACL,CAAG,CAAC;AACJ"}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapGetServerSidePropsWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapGetServerSidePropsWithSentry.ts"],"sourcesContent":["import type { GetServerSideProps } from 'next';\nimport { isBuild } from '../utils/isBuild';\nimport { withErrorInstrumentation, withTracedServerSideDataFetcher } from '../utils/wrapperUtils';\n\n/**\n * Create a wrapped version of the user's exported `getServerSideProps` function\n *\n * @param origGetServerSideProps The user's `getServerSideProps` function\n * @param parameterizedRoute The page's parameterized route\n * @returns A wrapped version of the function\n */\nexport function wrapGetServerSidePropsWithSentry(\n  origGetServerSideProps: GetServerSideProps,\n  parameterizedRoute: string,\n): GetServerSideProps {\n  return new Proxy(origGetServerSideProps, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<GetServerSideProps>) => {\n      if (isBuild()) {\n        return wrappingTarget.apply(thisArg, args);\n      }\n\n      const [context] = args;\n      const { req, res } = context;\n\n      const errorWrappedGetServerSideProps = withErrorInstrumentation(wrappingTarget);\n      const tracedGetServerSideProps = withTracedServerSideDataFetcher(errorWrappedGetServerSideProps, req, res, {\n        dataFetcherRouteName: parameterizedRoute,\n        requestedRouteName: parameterizedRoute,\n        dataFetchingMethodName: 'getServerSideProps',\n      });\n\n      const {\n        data: serverSideProps,\n        baggage,\n        sentryTrace,\n      }: {\n        data?: unknown;\n        baggage?: string;\n        sentryTrace?: string;\n      } = await (tracedGetServerSideProps.apply(thisArg, args) as ReturnType<typeof tracedGetServerSideProps>);\n\n      if (typeof serverSideProps === 'object' && serverSideProps !== null && 'props' in serverSideProps) {\n        // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n        if (sentryTrace) {\n          (serverSideProps.props as Record<string, unknown>)._sentryTraceData = sentryTrace;\n        }\n\n        // The Next.js serializer throws on undefined values so we need to guard for it (#12102)\n        if (baggage) {\n          (serverSideProps.props as Record<string, unknown>)._sentryBaggage = baggage;\n        }\n      }\n\n      return serverSideProps;\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAIA;;;;;;CAMA,GACO,SAAS,gCAAgC,CAC9C,sBAAsB,EACtB,kBAAkB;IAElB,OAAO,IAAI,KAAK,CAAC,sBAAsB,EAAE;QACvC,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAAqC;YAC9E,QAAI,mMAAO,EAAE,GAAE;gBACb,OAAO,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;YAC5C;YAEA,MAAM,CAAC,OAAO,CAAA,GAAI,IAAI;YACtB,MAAM,EAAE,GAAG,EAAE,GAAA,EAAI,GAAI,OAAO;YAE5B,MAAM,8BAAA,OAAiC,yNAAwB,EAAC,cAAc,CAAC;YAC/E,MAAM,wBAAA,OAA2B,gOAA+B,EAAC,8BAA8B,EAAE,GAAG,EAAE,GAAG,EAAE;gBACzG,oBAAoB,EAAE,kBAAkB;gBACxC,kBAAkB,EAAE,kBAAkB;gBACtC,sBAAsB,EAAE,oBAAoB;YACpD,CAAO,CAAC;YAEF,MAAM,EACJ,IAAI,EAAE,eAAe,EACrB,OAAO,EACP,WAAW,EACnB,GAIU,MAAO,wBAAwB,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAA,EAAiD;YAExG,IAAI,OAAO,eAAA,KAAoB,QAAA,IAAY,eAAA,KAAoB,IAAA,IAAQ,OAAA,IAAW,eAAe,EAAE;gBACzG,wFAAA;gBACQ,IAAI,WAAW,EAAE;oBACd,eAAe,CAAC,KAAA,CAAkC,gBAAA,GAAmB,WAAW;gBACnF;gBAER,wFAAA;gBACQ,IAAI,OAAO,EAAE;oBACV,eAAe,CAAC,KAAA,CAAkC,cAAA,GAAiB,OAAO;gBAC7E;YACF;YAEA,OAAO,eAAe;QACxB,CAAC;IACL,CAAG,CAAC;AACJ"}},
    {"offset": {"line": 977, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/nextNavigationErrorUtils.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/nextNavigationErrorUtils.ts"],"sourcesContent":["import { isError } from '@sentry/core';\n\n/**\n * Determines whether input is a Next.js not-found error.\n * https://beta.nextjs.org/docs/api-reference/notfound#notfound\n */\nexport function isNotFoundNavigationError(subject: unknown): boolean {\n  return (\n    isError(subject) &&\n    ['NEXT_NOT_FOUND', 'NEXT_HTTP_ERROR_FALLBACK;404'].includes(\n      (subject as Error & { digest?: unknown }).digest as string,\n    )\n  );\n}\n\n/**\n * Determines whether input is a Next.js redirect error.\n * https://beta.nextjs.org/docs/api-reference/redirect#redirect\n */\nexport function isRedirectNavigationError(subject: unknown): boolean {\n  return (\n    isError(subject) &&\n    typeof (subject as Error & { digest?: unknown }).digest === 'string' &&\n    (subject as Error & { digest: string }).digest.startsWith('NEXT_REDIRECT;') // a redirect digest looks like \"NEXT_REDIRECT;[redirect path]\"\n  );\n}\n"],"names":[],"mappings":";;;;;;;;AAEA;;;CAGA,GACO,SAAS,yBAAyB,CAAC,OAAO,EAAoB;IACnE,WACE,kLAAO,EAAC,OAAO,CAAA,IACf;QAAC,gBAAgB;QAAE,8BAA8B;KAAC,CAAC,QAAQ,CACzD,AAAC,OAAA,CAAyC,MAAA;AAGhD;AAEA;;;CAGA,GACO,SAAS,yBAAyB,CAAC,OAAO,EAAoB;IACnE,WACE,kLAAO,EAAC,OAAO,CAAA,IACf,OAAO,AAAC,OAAA,CAAyC,MAAA,KAAW,QAAA,IAC5D,AAAC,QAAuC,MAAM,CAAC,UAAU,CAAC,gBAAgB,CAAA,CAAA,+DAAA;;AAE9E"}},
    {"offset": {"line": 1007, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/tracingUtils.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/tracingUtils.ts"],"sourcesContent":["import type { PropagationContext } from '@sentry/core';\nimport { debug, getActiveSpan, getRootSpan, GLOBAL_OBJ, Scope, spanToJSON, startNewTrace } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION } from '../span-attributes-with-logic-attached';\n\nconst commonPropagationContextMap = new WeakMap<object, PropagationContext>();\n\n/**\n * Takes a shared (garbage collectable) object between resources, e.g. a headers object shared between Next.js server components and returns a common propagation context.\n *\n * @param commonObject The shared object.\n * @param propagationContext The propagation context that should be shared between all the resources if no propagation context was registered yet.\n * @returns the shared propagation context.\n */\nexport function commonObjectToPropagationContext(\n  commonObject: unknown,\n  propagationContext: PropagationContext,\n): PropagationContext {\n  if (typeof commonObject === 'object' && commonObject) {\n    const memoPropagationContext = commonPropagationContextMap.get(commonObject);\n    if (memoPropagationContext) {\n      return memoPropagationContext;\n    } else {\n      commonPropagationContextMap.set(commonObject, propagationContext);\n      return propagationContext;\n    }\n  } else {\n    return propagationContext;\n  }\n}\n\nconst commonIsolationScopeMap = new WeakMap<object, Scope>();\n\n/**\n * Takes a shared (garbage collectable) object between resources, e.g. a headers object shared between Next.js server components and returns a common propagation context.\n *\n * @param commonObject The shared object.\n * @param isolationScope The isolationScope that should be shared between all the resources if no isolation scope was created yet.\n * @returns the shared isolation scope.\n */\nexport function commonObjectToIsolationScope(commonObject: unknown): Scope {\n  if (typeof commonObject === 'object' && commonObject) {\n    const memoIsolationScope = commonIsolationScopeMap.get(commonObject);\n    if (memoIsolationScope) {\n      return memoIsolationScope;\n    } else {\n      const newIsolationScope = new Scope();\n      commonIsolationScopeMap.set(commonObject, newIsolationScope);\n      return newIsolationScope;\n    }\n  } else {\n    return new Scope();\n  }\n}\n\ninterface AsyncLocalStorage<T> {\n  getStore(): T | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  run<R, TArgs extends any[]>(store: T, callback: (...args: TArgs) => R, ...args: TArgs): R;\n}\n\nlet nextjsEscapedAsyncStorage: AsyncLocalStorage<true>;\n\n/**\n * Will mark the execution context of the callback as \"escaped\" from Next.js internal tracing by unsetting the active\n * span and propagation context. When an execution passes through this function multiple times, it is a noop after the\n * first time.\n */\nexport function escapeNextjsTracing<T>(cb: () => T): T {\n  const MaybeGlobalAsyncLocalStorage = (GLOBAL_OBJ as { AsyncLocalStorage?: new () => AsyncLocalStorage<true> })\n    .AsyncLocalStorage;\n\n  if (!MaybeGlobalAsyncLocalStorage) {\n    DEBUG_BUILD &&\n      debug.warn(\n        \"Tried to register AsyncLocalStorage async context strategy in a runtime that doesn't support AsyncLocalStorage.\",\n      );\n    return cb();\n  }\n\n  if (!nextjsEscapedAsyncStorage) {\n    nextjsEscapedAsyncStorage = new MaybeGlobalAsyncLocalStorage();\n  }\n\n  if (nextjsEscapedAsyncStorage.getStore()) {\n    return cb();\n  } else {\n    return startNewTrace(() => {\n      return nextjsEscapedAsyncStorage.run(true, () => {\n        return cb();\n      });\n    });\n  }\n}\n\n/**\n * Ideally this function never lands in the develop branch.\n *\n * Drops the entire span tree this function was called in, if it was a span tree created by Next.js.\n */\nexport function dropNextjsRootContext(): void {\n  const nextJsOwnedSpan = getActiveSpan();\n  if (nextJsOwnedSpan) {\n    const rootSpan = getRootSpan(nextJsOwnedSpan);\n    const rootSpanAttributes = spanToJSON(rootSpan).data;\n    if (rootSpanAttributes?.['next.span_type']) {\n      getRootSpan(nextJsOwnedSpan)?.setAttribute(TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION, true);\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAKA,MAAM,2BAAA,GAA8B,IAAI,OAAO,EAA8B;AAE7E;;;;;;CAMA,GACO,SAAS,gCAAgC,CAC9C,YAAY,EACZ,kBAAkB;IAElB,IAAI,OAAO,YAAA,KAAiB,QAAA,IAAY,YAAY,EAAE;QACpD,MAAM,yBAAyB,2BAA2B,CAAC,GAAG,CAAC,YAAY,CAAC;QAC5E,IAAI,sBAAsB,EAAE;YAC1B,OAAO,sBAAsB;QAC/B,OAAO;YACL,2BAA2B,CAAC,GAAG,CAAC,YAAY,EAAE,kBAAkB,CAAC;YACjE,OAAO,kBAAkB;QAC3B;IACF,OAAO;QACL,OAAO,kBAAkB;IAC3B;AACF;AAEA,MAAM,uBAAA,GAA0B,IAAI,OAAO,EAAiB;AAE5D;;;;;;CAMA,GACO,SAAS,4BAA4B,CAAC,YAAY,EAAkB;IACzE,IAAI,OAAO,YAAA,KAAiB,QAAA,IAAY,YAAY,EAAE;QACpD,MAAM,qBAAqB,uBAAuB,CAAC,GAAG,CAAC,YAAY,CAAC;QACpE,IAAI,kBAAkB,EAAE;YACtB,OAAO,kBAAkB;QAC3B,OAAO;YACL,MAAM,iBAAA,GAAoB,IAAI,0KAAK,EAAE;YACrC,uBAAuB,CAAC,GAAG,CAAC,YAAY,EAAE,iBAAiB,CAAC;YAC5D,OAAO,iBAAiB;QAC1B;IACF,OAAO;QACL,OAAO,IAAI,0KAAK,EAAE;IACpB;AACF;AAQA,IAAI,yBAAyB;AAE7B;;;;CAIA,GACO,SAAS,mBAAmB,CAAI,EAAE,EAAc;IACrD,MAAM,4BAAA,GAA+B,AAAC,4LAAA,CACnC,iBAAiB;IAEpB,IAAI,CAAC,4BAA4B,EAAE;QACjC,qMAAA,IACE,6LAAK,CAAC,IAAI,CACR,iHAAiH;QAErH,OAAO,EAAE,EAAE;IACb;IAEA,IAAI,CAAC,yBAAyB,EAAE;QAC9B,yBAAA,GAA4B,IAAI,4BAA4B,EAAE;IAChE;IAEA,IAAI,yBAAyB,CAAC,QAAQ,EAAE,EAAE;QACxC,OAAO,EAAE,EAAE;IACb,OAAO;QACL,WAAO,6LAAa,EAAC,MAAM;YACzB,OAAO,yBAAyB,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM;gBAC/C,OAAO,EAAE,EAAE;YACb,CAAC,CAAC;QACJ,CAAC,CAAC;IACJ;AACF;AAEA;;;;CAIA,GACO,SAAS,qBAAqB,GAAS;IAC5C,MAAM,eAAA,OAAkB,+LAAa,EAAE;IACvC,IAAI,eAAe,EAAE;QACnB,MAAM,QAAA,OAAW,6LAAW,EAAC,eAAe,CAAC;QAC7C,MAAM,yBAAqB,4LAAU,EAAC,QAAQ,CAAC,CAAC,IAAI;QACpD,IAAI,kBAAkB,EAAA,CAAG,gBAAgB,CAAC,EAAE;gBAC1C,6LAAW,EAAC,eAAe,CAAC,EAAE,YAAY,CAAC,mQAAwC,EAAE,IAAI,CAAC;QAC5F;IACF;AACF"}},
    {"offset": {"line": 1112, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/wrapServerComponentWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/wrapServerComponentWithSentry.ts"],"sourcesContent":["import type { RequestEventData } from '@sentry/core';\nimport {\n  captureException,\n  getActiveSpan,\n  getCapturedScopesOnSpan,\n  getRootSpan,\n  handleCallbackErrors,\n  propagationContextFromHeaders,\n  Scope,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setCapturedScopesOnSpan,\n  SPAN_STATUS_ERROR,\n  SPAN_STATUS_OK,\n  startSpanManual,\n  winterCGHeadersToDict,\n  withIsolationScope,\n  withScope,\n} from '@sentry/core';\nimport { isNotFoundNavigationError, isRedirectNavigationError } from '../common/nextNavigationErrorUtils';\nimport type { ServerComponentContext } from '../common/types';\nimport { flushSafelyWithTimeout, waitUntil } from '../common/utils/responseEnd';\nimport { TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL } from './span-attributes-with-logic-attached';\nimport { commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils';\n\n/**\n * Wraps an `app` directory server component with Sentry error instrumentation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function wrapServerComponentWithSentry<F extends (...args: any[]) => any>(\n  appDirComponent: F,\n  context: ServerComponentContext,\n): F {\n  const { componentRoute, componentType } = context;\n  // Even though users may define server components as async functions, for the client bundles\n  // Next.js will turn them into synchronous functions and it will transform any `await`s into instances of the `use`\n  // hook. \n  return new Proxy(appDirComponent, {\n    apply: (originalFunction, thisArg, args) => {\n      const requestTraceId = getActiveSpan()?.spanContext().traceId;\n      const isolationScope = commonObjectToIsolationScope(context.headers);\n\n      const activeSpan = getActiveSpan();\n      if (activeSpan) {\n        const rootSpan = getRootSpan(activeSpan);\n        const { scope } = getCapturedScopesOnSpan(rootSpan);\n        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);\n      }\n\n      const headersDict = context.headers ? winterCGHeadersToDict(context.headers) : undefined;\n\n      isolationScope.setSDKProcessingMetadata({\n        normalizedRequest: {\n          headers: headersDict,\n        } satisfies RequestEventData,\n      });\n\n      return withIsolationScope(isolationScope, () => {\n        return withScope(scope => {\n          scope.setTransactionName(`${componentType} Server Component (${componentRoute})`);\n\n          if (process.env.NEXT_RUNTIME === 'edge') {\n            const propagationContext = commonObjectToPropagationContext(\n              context.headers,\n              propagationContextFromHeaders(headersDict?.['sentry-trace'], headersDict?.['baggage']),\n            );\n\n            if (requestTraceId) {\n              propagationContext.traceId = requestTraceId;\n            }\n\n            scope.setPropagationContext(propagationContext);\n          }\n\n          const activeSpan = getActiveSpan();\n          if (activeSpan) {\n            const rootSpan = getRootSpan(activeSpan);\n            const sentryTrace = headersDict?.['sentry-trace'];\n            if (sentryTrace) {\n              rootSpan.setAttribute(TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL, sentryTrace);\n            }\n          }\n\n          return startSpanManual(\n            {\n              op: 'function.nextjs',\n              name: `${componentType} Server Component (${componentRoute})`,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'component',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.server_component',\n                'sentry.nextjs.ssr.function.type': componentType,\n                'sentry.nextjs.ssr.function.route': componentRoute,\n              },\n            },\n            span => {\n              return handleCallbackErrors(\n                () => originalFunction.apply(thisArg, args),\n                error => {\n                  // When you read this code you might think: \"Wait a minute, shouldn't we set the status on the root span too?\"\n                  // The answer is: \"No.\" - The status of the root span is determined by whatever status code Next.js decides to put on the response.\n                  if (isNotFoundNavigationError(error)) {\n                    // We don't want to report \"not-found\"s\n                    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });\n                  } else if (isRedirectNavigationError(error)) {\n                    // We don't want to report redirects\n                    span.setStatus({ code: SPAN_STATUS_OK });\n                  } else {\n                    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n                    captureException(error, {\n                      mechanism: {\n                        handled: false,\n                        type: 'auto.function.nextjs.server_component',\n                      },\n                    });\n                  }\n                },\n                () => {\n                  span.end();\n                  waitUntil(flushSafelyWithTimeout());\n                },\n              );\n            },\n          );\n        });\n      });\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;CAEA,GACA,8DAAA;AACO,SAAS,6BAA6B,CAC3C,eAAe,EACf,OAAO;IAEP,MAAM,EAAE,cAAc,EAAE,aAAA,EAAc,GAAI,OAAO;IACnD,4FAAA;IACA,mHAAA;IACA,WAAA;IACE,OAAO,IAAI,KAAK,CAAC,eAAe,EAAE;QAChC,KAAK,EAAE,CAAC,gBAAgB,EAAE,OAAO,EAAE,IAAI,KAAK;YAC1C,MAAM,cAAA,OAAiB,+LAAa,EAAE,GAAE,WAAW,EAAE,CAAC,OAAO;YAC7D,MAAM,qBAAiB,6NAA4B,EAAC,OAAO,CAAC,OAAO,CAAC;YAEpE,MAAM,UAAA,OAAa,+LAAa,EAAE;YAClC,IAAI,UAAU,EAAE;gBACd,MAAM,QAAA,OAAW,6LAAW,EAAC,UAAU,CAAC;gBACxC,MAAM,EAAE,KAAA,EAAM,OAAI,uMAAuB,EAAC,QAAQ,CAAC;oBACnD,uMAAuB,EAAC,QAAQ,EAAE,KAAA,IAAS,IAAI,0KAAK,EAAE,EAAE,cAAc,CAAC;YACzE;YAEA,MAAM,WAAA,GAAc,OAAO,CAAC,OAAA,OAAU,qMAAqB,EAAC,OAAO,CAAC,OAAO,CAAA,GAAI,SAAS;YAExF,cAAc,CAAC,wBAAwB,CAAC;gBACtC,iBAAiB,EAAE;oBACjB,OAAO,EAAE,WAAW;gBAC9B,CAAQ;YACR,CAAO,CAAC;YAEF,WAAO,+LAAkB,EAAC,cAAc,EAAE,MAAM;gBAC9C,WAAO,sLAAS,GAAC,KAAA,IAAS;oBACxB,KAAK,CAAC,kBAAkB,CAAC,CAAC,EAAA,aAAA,CAAA,mBAAA,EAAA,cAAA,CAAA,CAAA,CAAA,CAAA;oBAEA,IAAA,OAAA,CAAA,GAAA,CAAA,YAAA,KAAA,MAAA,CAAA;wBACA,MAAA,kBAAA,OAAA,iOAAA,EACA,OAAA,CAAA,OAAA,MACA,6MAAA,EAAA,WAAA,EAAA,CAAA,cAAA,CAAA,EAAA,WAAA,EAAA,CAAA,SAAA,CAAA,CAAA;wBAGA,IAAA,cAAA,EAAA;4BACA,kBAAA,CAAA,OAAA,GAAA,cAAA;wBACA;wBAEA,KAAA,CAAA,qBAAA,CAAA,kBAAA,CAAA;oBACA;oBAEA,MAAA,UAAA,OAAA,+LAAA,EAAA;oBACA,IAAA,UAAA,EAAA;wBACA,MAAA,QAAA,OAAA,6LAAA,EAAA,UAAA,CAAA;wBACA,MAAA,WAAA,GAAA,WAAA,EAAA,CAAA,cAAA,CAAA;wBACA,IAAA,WAAA,EAAA;4BACA,QAAA,CAAA,YAAA,CAAA,iQAAA,EAAA,WAAA,CAAA;wBACA;oBACA;oBAEA,WAAA,+LAAA,EACA;wBACA,EAAA,EAAA,iBAAA;wBACA,IAAA,EAAA,CAAA,EAAA,aAAA,CAAA,mBAAA,EAAA,cAAA,CAAA,CAAA,CAAA;wBACA,UAAA,EAAA;4BACA,CAAA,kNAAA,CAAA,EAAA,WAAA;4BACA,CAAA,kNAAA,CAAA,EAAA,uCAAA;4BACA,iCAAA,EAAA,aAAA;4BACA,kCAAA,EAAA,cAAA;wBACA,CAAA;oBACA,CAAA,GACA,IAAA,IAAA;wBACA,WAAA,iNAAA,EACA,IAAA,gBAAA,CAAA,KAAA,CAAA,OAAA,EAAA,IAAA,CAAA,GACA,KAAA,IAAA;4BACA,8GAAA;4BACA,mIAAA;4BACA,QAAA,6NAAA,EAAA,KAAA,CAAA,EAAA;gCACA,uCAAA;gCACA,IAAA,CAAA,SAAA,CAAA;oCAAA,IAAA,EAAA,sMAAA;oCAAA,OAAA,EAAA,WAAA;gCAAA,CAAA,CAAA;4BACA,CAAA,MAAA,QAAA,6NAAA,EAAA,KAAA,CAAA,EAAA;gCACA,oCAAA;gCACA,IAAA,CAAA,SAAA,CAAA;oCAAA,IAAA,EAAA,mMAAA;gCAAA,CAAA,CAAA;4BACA,CAAA,MAAA;gCACA,IAAA,CAAA,SAAA,CAAA;oCAAA,IAAA,EAAA,sMAAA;oCAAA,OAAA,EAAA,gBAAA;gCAAA,CAAA,CAAA;oCACA,uLAAA,EAAA,KAAA,EAAA;oCACA,SAAA,EAAA;wCACA,OAAA,EAAA,KAAA;wCACA,IAAA,EAAA,uCAAA;oCACA,CAAA;gCACA,CAAA,CAAA;4BACA;wBACA,CAAA,EACA,MAAA;4BACA,IAAA,CAAA,GAAA,EAAA;gCACA,yMAAA,MAAA,sNAAA,EAAA,CAAA;wBACA,CAAA;oBAEA,CAAA;gBAEA,CAAA,CAAA;YACA,CAAA,CAAA;QACA,CAAA;IACA,CAAA,CAAA;AACA"}},
    {"offset": {"line": 1230, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/wrapRouteHandlerWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/wrapRouteHandlerWithSentry.ts"],"sourcesContent":["import type { RequestEventData } from '@sentry/core';\nimport {\n  captureException,\n  getActiveSpan,\n  getCapturedScopesOnSpan,\n  getIsolationScope,\n  getRootSpan,\n  handleCallbackErrors,\n  propagationContextFromHeaders,\n  Scope,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setCapturedScopesOnSpan,\n  setHttpStatus,\n  winterCGHeadersToDict,\n  withIsolationScope,\n  withScope,\n} from '@sentry/core';\nimport { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';\nimport type { RouteHandlerContext } from './types';\nimport { flushSafelyWithTimeout, waitUntil } from './utils/responseEnd';\nimport { commonObjectToIsolationScope } from './utils/tracingUtils';\n\n/**\n * Wraps a Next.js App Router Route handler with Sentry error and performance instrumentation.\n *\n * NOTICE: This wrapper is for App Router API routes. If you are looking to wrap Pages Router API routes use `wrapApiHandlerWithSentry` instead.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function wrapRouteHandlerWithSentry<F extends (...args: any[]) => any>(\n  routeHandler: F,\n  context: RouteHandlerContext,\n): (...args: Parameters<F>) => ReturnType<F> extends Promise<unknown> ? ReturnType<F> : Promise<ReturnType<F>> {\n  const { method, parameterizedRoute, headers } = context;\n\n  return new Proxy(routeHandler, {\n    apply: async (originalFunction, thisArg, args) => {\n      const activeSpan = getActiveSpan();\n      const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;\n\n      let edgeRuntimeIsolationScopeOverride: Scope | undefined;\n      if (rootSpan && process.env.NEXT_RUNTIME === 'edge') {\n        const isolationScope = commonObjectToIsolationScope(headers);\n        const { scope } = getCapturedScopesOnSpan(rootSpan);\n        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);\n\n        edgeRuntimeIsolationScopeOverride = isolationScope;\n\n        rootSpan.updateName(`${method} ${parameterizedRoute}`);\n        rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');\n        rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'http.server');\n      }\n\n      return withIsolationScope(\n        process.env.NEXT_RUNTIME === 'edge' ? edgeRuntimeIsolationScopeOverride : getIsolationScope(),\n        () => {\n          return withScope(async scope => {\n            scope.setTransactionName(`${method} ${parameterizedRoute}`);\n\n            if (process.env.NEXT_RUNTIME === 'edge') {\n              const completeHeadersDict: Record<string, string> = headers ? winterCGHeadersToDict(headers) : {};\n              const incomingPropagationContext = propagationContextFromHeaders(\n                completeHeadersDict['sentry-trace'],\n                completeHeadersDict['baggage'],\n              );\n              scope.setPropagationContext(incomingPropagationContext);\n              scope.setSDKProcessingMetadata({\n                normalizedRequest: {\n                  method,\n                  headers: completeHeadersDict,\n                } satisfies RequestEventData,\n              });\n            }\n\n            const response: Response = await handleCallbackErrors(\n              () => originalFunction.apply(thisArg, args),\n              error => {\n                // Next.js throws errors when calling `redirect()`. We don't wanna report these.\n                if (isRedirectNavigationError(error)) {\n                  // Don't do anything\n                } else if (isNotFoundNavigationError(error)) {\n                  if (activeSpan) {\n                    setHttpStatus(activeSpan, 404);\n                  }\n                  if (rootSpan) {\n                    setHttpStatus(rootSpan, 404);\n                  }\n                } else {\n                  captureException(error, {\n                    mechanism: {\n                      handled: false,\n                      type: 'auto.function.nextjs.route_handler',\n                    },\n                  });\n                }\n              },\n              () => {\n                waitUntil(flushSafelyWithTimeout());\n              },\n            );\n\n            try {\n              if (response.status) {\n                if (activeSpan) {\n                  setHttpStatus(activeSpan, response.status);\n                }\n                if (rootSpan) {\n                  setHttpStatus(rootSpan, response.status);\n                }\n              }\n            } catch {\n              // best effort - response may be undefined?\n            }\n\n            return response;\n          });\n        },\n      );\n    },\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1331, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapApiHandlerWithSentryVercelCrons.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapApiHandlerWithSentryVercelCrons.ts"],"sourcesContent":["import { captureCheckIn } from '@sentry/core';\nimport type { NextApiRequest } from 'next';\nimport type { VercelCronsConfig } from '../types';\n\ntype EdgeRequest = {\n  nextUrl: URL;\n  headers: Headers;\n};\n\n/**\n * Wraps a function with Sentry crons instrumentation by automatically sending check-ins for the given Vercel crons config.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function wrapApiHandlerWithSentryVercelCrons<F extends (...args: any[]) => any>(\n  handler: F,\n  vercelCronsConfig: VercelCronsConfig,\n): F {\n  return new Proxy(handler, {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    apply: (originalFunction, thisArg, args: any[]) => {\n      if (!args?.[0]) {\n        return originalFunction.apply(thisArg, args);\n      }\n\n      const [req] = args as [NextApiRequest | EdgeRequest];\n\n      let maybePromiseResult;\n      const cronsKey = 'nextUrl' in req ? req.nextUrl.pathname : req.url;\n      const userAgentHeader = 'nextUrl' in req ? req.headers.get('user-agent') : req.headers['user-agent'];\n\n      if (\n        !vercelCronsConfig || // do nothing if vercel crons config is missing\n        !userAgentHeader?.includes('vercel-cron') // do nothing if endpoint is not called from vercel crons\n      ) {\n        return originalFunction.apply(thisArg, args);\n      }\n\n      const vercelCron = vercelCronsConfig.find(vercelCron => vercelCron.path === cronsKey);\n\n      if (!vercelCron?.path || !vercelCron.schedule) {\n        return originalFunction.apply(thisArg, args);\n      }\n\n      const monitorSlug = vercelCron.path;\n\n      const checkInId = captureCheckIn(\n        {\n          monitorSlug,\n          status: 'in_progress',\n        },\n        {\n          maxRuntime: 60 * 12, // (minutes) so 12 hours - just a very high arbitrary number since we don't know the actual duration of the users cron job\n          schedule: {\n            type: 'crontab',\n            value: vercelCron.schedule,\n          },\n        },\n      );\n\n      const startTime = Date.now() / 1000;\n\n      const handleErrorCase = (): void => {\n        captureCheckIn({\n          checkInId,\n          monitorSlug,\n          status: 'error',\n          duration: Date.now() / 1000 - startTime,\n        });\n      };\n\n      try {\n        maybePromiseResult = originalFunction.apply(thisArg, args);\n      } catch (e) {\n        handleErrorCase();\n        throw e;\n      }\n\n      if (typeof maybePromiseResult === 'object' && maybePromiseResult !== null && 'then' in maybePromiseResult) {\n        Promise.resolve(maybePromiseResult).then(\n          () => {\n            captureCheckIn({\n              checkInId,\n              monitorSlug,\n              status: 'ok',\n              duration: Date.now() / 1000 - startTime,\n            });\n          },\n          () => {\n            handleErrorCase();\n          },\n        );\n\n        // It is very important that we return the original promise here, because Next.js attaches various properties\n        // to that promise and will throw if they are not on the returned value.\n        return maybePromiseResult;\n      } else {\n        captureCheckIn({\n          checkInId,\n          monitorSlug,\n          status: 'ok',\n          duration: Date.now() / 1000 - startTime,\n        });\n        return maybePromiseResult;\n      }\n    },\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1418, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/wrapMiddlewareWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/wrapMiddlewareWithSentry.ts"],"sourcesContent":["import type { TransactionSource } from '@sentry/core';\nimport {\n  captureException,\n  getActiveSpan,\n  getCurrentScope,\n  getRootSpan,\n  handleCallbackErrors,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setCapturedScopesOnSpan,\n  startSpan,\n  winterCGRequestToRequestData,\n  withIsolationScope,\n} from '@sentry/core';\nimport { flushSafelyWithTimeout, waitUntil } from '../common/utils/responseEnd';\nimport type { EdgeRouteHandler } from '../edge/types';\n\n/**\n * Wraps Next.js middleware with Sentry error and performance instrumentation.\n *\n * @param middleware The middleware handler.\n * @returns a wrapped middleware handler.\n */\nexport function wrapMiddlewareWithSentry<H extends EdgeRouteHandler>(\n  middleware: H,\n): (...params: Parameters<H>) => Promise<ReturnType<H>> {\n  return new Proxy(middleware, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {\n      const tunnelRoute =\n        '_sentryRewritesTunnelPath' in globalThis\n          ? (globalThis as Record<string, unknown>)._sentryRewritesTunnelPath\n          : undefined;\n\n      if (tunnelRoute && typeof tunnelRoute === 'string') {\n        const req: unknown = args[0];\n        // Check if the current request matches the tunnel route\n        if (req instanceof Request) {\n          const url = new URL(req.url);\n          const isTunnelRequest = url.pathname.startsWith(tunnelRoute);\n\n          if (isTunnelRequest) {\n            // Create a simple response that mimics NextResponse.next() so we don't need to import internals here\n            // which breaks next 13 apps\n            // https://github.com/vercel/next.js/blob/c12c9c1f78ad384270902f0890dc4cd341408105/packages/next/src/server/web/spec-extension/response.ts#L146\n            return new Response(null, {\n              status: 200,\n              headers: {\n                'x-middleware-next': '1',\n              },\n            }) as ReturnType<H>;\n          }\n        }\n      }\n      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.\n      return withIsolationScope(isolationScope => {\n        const req: unknown = args[0];\n        const currentScope = getCurrentScope();\n\n        let spanName: string;\n        let spanSource: TransactionSource;\n\n        if (req instanceof Request) {\n          isolationScope.setSDKProcessingMetadata({\n            normalizedRequest: winterCGRequestToRequestData(req),\n          });\n          spanName = `middleware ${req.method}`;\n          spanSource = 'url';\n        } else {\n          spanName = 'middleware';\n          spanSource = 'component';\n        }\n\n        currentScope.setTransactionName(spanName);\n\n        const activeSpan = getActiveSpan();\n\n        if (activeSpan) {\n          // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can\n          // rely on that for parameterization.\n          spanName = 'middleware';\n          spanSource = 'component';\n\n          const rootSpan = getRootSpan(activeSpan);\n          if (rootSpan) {\n            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);\n          }\n        }\n\n        return startSpan(\n          {\n            name: spanName,\n            op: 'http.server.middleware',\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: spanSource,\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrap_middleware',\n            },\n          },\n          () => {\n            return handleCallbackErrors(\n              () => wrappingTarget.apply(thisArg, args),\n              error => {\n                captureException(error, {\n                  mechanism: {\n                    type: 'auto.function.nextjs.wrap_middleware',\n                    handled: false,\n                  },\n                });\n              },\n              () => {\n                waitUntil(flushSafelyWithTimeout());\n              },\n            );\n          },\n        );\n      });\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAiBA;;;;;CAKA,GACO,SAAS,wBAAwB,CACtC,UAAU;IAEV,OAAO,IAAI,KAAK,CAAC,UAAU,EAAE;QAC3B,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAAoB;YAC7D,MAAM,WAAA,GACJ,+BAA+B,aAC3B,AAAC,UAAA,CAAuC,yBAAA,GACxC,SAAS;YAEf,IAAI,WAAA,IAAe,OAAO,WAAA,KAAgB,QAAQ,EAAE;gBAClD,MAAM,GAAG,GAAY,IAAI,CAAC,CAAC,CAAC;gBACpC,wDAAA;gBACQ,IAAI,GAAA,YAAe,OAAO,EAAE;oBAC1B,MAAM,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;oBAC5B,MAAM,eAAA,GAAkB,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,WAAW,CAAC;oBAE5D,IAAI,eAAe,EAAE;wBAC/B,qGAAA;wBACA,4BAAA;wBACA,+IAAA;wBACY,OAAO,IAAI,QAAQ,CAAC,IAAI,EAAE;4BACxB,MAAM,EAAE,GAAG;4BACX,OAAO,EAAE;gCACP,mBAAmB,EAAE,GAAG;4BACxC,CAAe;wBACf,CAAa,CAAA;oBACH;gBACF;YACF;YACN,2IAAA;YACM,WAAO,+LAAkB,GAAC,cAAA,IAAkB;gBAC1C,MAAM,GAAG,GAAY,IAAI,CAAC,CAAC,CAAC;gBAC5B,MAAM,YAAA,OAAe,4LAAe,EAAE;gBAEtC,IAAI,QAAQ;gBACZ,IAAI,UAAU;gBAEd,IAAI,GAAA,YAAe,OAAO,EAAE;oBAC1B,cAAc,CAAC,wBAAwB,CAAC;wBACtC,iBAAiB,MAAE,4MAA4B,EAAC,GAAG,CAAC;oBAChE,CAAW,CAAC;oBACF,QAAA,GAAW,CAAC,WAAW,EAAE,GAAG,CAAC,MAAM,CAAC,CAAA;oBACA,UAAA,GAAA,KAAA;gBACA,CAAA,MAAA;oBACA,QAAA,GAAA,YAAA;oBACA,UAAA,GAAA,WAAA;gBACA;gBAEA,YAAA,CAAA,kBAAA,CAAA,QAAA,CAAA;gBAEA,MAAA,UAAA,OAAA,+LAAA,EAAA;gBAEA,IAAA,UAAA,EAAA;oBACA,gHAAA;oBACA,qCAAA;oBACA,QAAA,GAAA,YAAA;oBACA,UAAA,GAAA,WAAA;oBAEA,MAAA,QAAA,OAAA,6LAAA,EAAA,UAAA,CAAA;oBACA,IAAA,QAAA,EAAA;4BACA,uMAAA,EAAA,QAAA,EAAA,YAAA,EAAA,cAAA,CAAA;oBACA;gBACA;gBAEA,WAAA,yLAAA,EACA;oBACA,IAAA,EAAA,QAAA;oBACA,EAAA,EAAA,wBAAA;oBACA,UAAA,EAAA;wBACA,CAAA,kNAAA,CAAA,EAAA,UAAA;wBACA,CAAA,kNAAA,CAAA,EAAA,sCAAA;oBACA,CAAA;gBACA,CAAA,EACA,MAAA;oBACA,WAAA,iNAAA,EACA,IAAA,cAAA,CAAA,KAAA,CAAA,OAAA,EAAA,IAAA,CAAA,GACA,KAAA,IAAA;4BACA,uLAAA,EAAA,KAAA,EAAA;4BACA,SAAA,EAAA;gCACA,IAAA,EAAA,sCAAA;gCACA,OAAA,EAAA,KAAA;4BACA,CAAA;wBACA,CAAA,CAAA;oBACA,CAAA,EACA,MAAA;4BACA,yMAAA,MAAA,sNAAA,EAAA,CAAA;oBACA,CAAA;gBAEA,CAAA;YAEA,CAAA,CAAA;QACA,CAAA;IACA,CAAA,CAAA;AACA"}},
    {"offset": {"line": 1518, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/wrapPageComponentWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/wrapPageComponentWithSentry.ts"],"sourcesContent":["import { captureException, extractTraceparentData, getCurrentScope, withIsolationScope } from '@sentry/core';\n\ninterface FunctionComponent {\n  (...args: unknown[]): unknown;\n}\n\ninterface ClassComponent {\n  new (...args: unknown[]): {\n    props?: unknown;\n    render(...args: unknown[]): unknown;\n  };\n}\n\nfunction isReactClassComponent(target: unknown): target is ClassComponent {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return typeof target === 'function' && target?.prototype?.isReactComponent;\n}\n\n/**\n * Wraps a page component with Sentry error instrumentation.\n */\nexport function wrapPageComponentWithSentry(pageComponent: FunctionComponent | ClassComponent): unknown {\n  if (isReactClassComponent(pageComponent)) {\n    return class SentryWrappedPageComponent extends pageComponent {\n      public render(...args: unknown[]): unknown {\n        return withIsolationScope(() => {\n          const scope = getCurrentScope();\n          // We extract the sentry trace data that is put in the component props by datafetcher wrappers\n          const sentryTraceData =\n            typeof this.props === 'object' &&\n            this.props !== null &&\n            '_sentryTraceData' in this.props &&\n            typeof this.props._sentryTraceData === 'string'\n              ? this.props._sentryTraceData\n              : undefined;\n\n          if (sentryTraceData) {\n            const traceparentData = extractTraceparentData(sentryTraceData);\n            scope.setContext('trace', {\n              span_id: traceparentData?.parentSpanId,\n              trace_id: traceparentData?.traceId,\n            });\n          }\n\n          try {\n            return super.render(...args);\n          } catch (e) {\n            captureException(e, {\n              mechanism: {\n                handled: false,\n                type: 'auto.function.nextjs.page_class',\n              },\n            });\n            throw e;\n          }\n        });\n      }\n    };\n  } else if (typeof pageComponent === 'function') {\n    return new Proxy(pageComponent, {\n      apply(target, thisArg, argArray: [{ _sentryTraceData?: string } | undefined]) {\n        return withIsolationScope(() => {\n          const scope = getCurrentScope();\n          // We extract the sentry trace data that is put in the component props by datafetcher wrappers\n          const sentryTraceData = argArray?.[0]?._sentryTraceData;\n\n          if (sentryTraceData) {\n            const traceparentData = extractTraceparentData(sentryTraceData);\n            scope.setContext('trace', {\n              span_id: traceparentData?.parentSpanId,\n              trace_id: traceparentData?.traceId,\n            });\n          }\n\n          try {\n            return target.apply(thisArg, argArray);\n          } catch (e) {\n            captureException(e, {\n              mechanism: {\n                handled: false,\n                type: 'auto.function.nextjs.page_function',\n              },\n            });\n            throw e;\n          }\n        });\n      },\n    });\n  } else {\n    return pageComponent;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAaA,SAAS,qBAAqB,CAAC,MAAM,EAAqC;IAC1E,sEAAA;IACE,OAAO,OAAO,MAAA,KAAW,UAAA,IAAc,MAAM,EAAE,SAAS,EAAE,gBAAgB;AAC5E;AAEA;;CAEA,GACO,SAAS,2BAA2B,CAAC,aAAa,EAA+C;IACtG,IAAI,qBAAqB,CAAC,aAAa,CAAC,EAAE;QACxC,OAAO,MAAM,0BAAA,SAAmC,aAAA,CAAc;YACrD,MAAM,CAAC,GAAG,IAAI,EAAsB;gBACzC,WAAO,+LAAkB,EAAC,MAAM;oBAC9B,MAAM,KAAA,OAAQ,4LAAe,EAAE;oBACzC,8FAAA;oBACU,MAAM,eAAA,GACJ,OAAO,IAAI,CAAC,KAAA,KAAU,QAAA,IACtB,IAAI,CAAC,KAAA,KAAU,IAAA,IACf,kBAAA,IAAsB,IAAI,CAAC,KAAA,IAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,gBAAA,KAAqB,WACnC,IAAI,CAAC,KAAK,CAAC,gBAAA,GACX,SAAS;oBAEf,IAAI,eAAe,EAAE;wBACnB,MAAM,eAAA,OAAkB,sMAAsB,EAAC,eAAe,CAAC;wBAC/D,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE;4BACxB,OAAO,EAAE,eAAe,EAAE,YAAY;4BACtC,QAAQ,EAAE,eAAe,EAAE,OAAO;wBAChD,CAAa,CAAC;oBACJ;oBAEA,IAAI;wBACF,OAAO,KAAK,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;oBAC9B,CAAA,CAAE,OAAO,CAAC,EAAE;4BACV,uLAAgB,EAAC,CAAC,EAAE;4BAClB,SAAS,EAAE;gCACT,OAAO,EAAE,KAAK;gCACd,IAAI,EAAE,iCAAiC;4BACvD,CAAe;wBACf,CAAa,CAAC;wBACF,MAAM,CAAC;oBACT;gBACF,CAAC,CAAC;YACJ;QACN,CAAK;IACH,CAAA,MAAO,IAAI,OAAO,aAAA,KAAkB,UAAU,EAAE;QAC9C,OAAO,IAAI,KAAK,CAAC,aAAa,EAAE;YAC9B,KAAK,EAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAA+C;gBAC5E,WAAO,+LAAkB,EAAC,MAAM;oBAC9B,MAAM,KAAA,OAAQ,4LAAe,EAAE;oBACzC,8FAAA;oBACU,MAAM,kBAAkB,QAAQ,EAAA,CAAG,CAAC,CAAC,EAAE,gBAAgB;oBAEvD,IAAI,eAAe,EAAE;wBACnB,MAAM,eAAA,OAAkB,sMAAsB,EAAC,eAAe,CAAC;wBAC/D,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE;4BACxB,OAAO,EAAE,eAAe,EAAE,YAAY;4BACtC,QAAQ,EAAE,eAAe,EAAE,OAAO;wBAChD,CAAa,CAAC;oBACJ;oBAEA,IAAI;wBACF,OAAO,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC;oBACxC,CAAA,CAAE,OAAO,CAAC,EAAE;4BACV,uLAAgB,EAAC,CAAC,EAAE;4BAClB,SAAS,EAAE;gCACT,OAAO,EAAE,KAAK;gCACd,IAAI,EAAE,oCAAoC;4BAC1D,CAAe;wBACf,CAAa,CAAC;wBACF,MAAM,CAAC;oBACT;gBACF,CAAC,CAAC;YACJ,CAAC;QACP,CAAK,CAAC;IACJ,OAAO;QACL,OAAO,aAAa;IACtB;AACF"}},
    {"offset": {"line": 1599, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/wrapGenerationFunctionWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/wrapGenerationFunctionWithSentry.ts"],"sourcesContent":["import type { RequestEventData, WebFetchHeaders } from '@sentry/core';\nimport {\n  captureException,\n  getActiveSpan,\n  getCapturedScopesOnSpan,\n  getRootSpan,\n  handleCallbackErrors,\n  propagationContextFromHeaders,\n  Scope,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setCapturedScopesOnSpan,\n  SPAN_STATUS_ERROR,\n  SPAN_STATUS_OK,\n  startSpanManual,\n  winterCGHeadersToDict,\n  withIsolationScope,\n  withScope,\n} from '@sentry/core';\nimport type { GenerationFunctionContext } from '../common/types';\nimport { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';\nimport { TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL } from './span-attributes-with-logic-attached';\nimport { commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils';\n/**\n * Wraps a generation function (e.g. generateMetadata) with Sentry error and performance instrumentation.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function wrapGenerationFunctionWithSentry<F extends (...args: any[]) => any>(\n  generationFunction: F,\n  context: GenerationFunctionContext,\n): F {\n  const { requestAsyncStorage, componentRoute, componentType, generationFunctionIdentifier } = context;\n  return new Proxy(generationFunction, {\n    apply: (originalFunction, thisArg, args) => {\n      const requestTraceId = getActiveSpan()?.spanContext().traceId;\n      let headers: WebFetchHeaders | undefined = undefined;\n      // We try-catch here just in case anything goes wrong with the async storage here goes wrong since it is Next.js internal API\n      try {\n        headers = requestAsyncStorage?.getStore()?.headers;\n      } catch {\n        /** empty */\n      }\n\n      const isolationScope = commonObjectToIsolationScope(headers);\n\n      const activeSpan = getActiveSpan();\n      if (activeSpan) {\n        const rootSpan = getRootSpan(activeSpan);\n        const { scope } = getCapturedScopesOnSpan(rootSpan);\n        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);\n      }\n\n      const headersDict = headers ? winterCGHeadersToDict(headers) : undefined;\n\n      return withIsolationScope(isolationScope, () => {\n        return withScope(scope => {\n          scope.setTransactionName(`${componentType}.${generationFunctionIdentifier} (${componentRoute})`);\n\n          isolationScope.setSDKProcessingMetadata({\n            normalizedRequest: {\n              headers: headersDict,\n            } satisfies RequestEventData,\n          });\n\n          const activeSpan = getActiveSpan();\n          if (activeSpan) {\n            const rootSpan = getRootSpan(activeSpan);\n            const sentryTrace = headersDict?.['sentry-trace'];\n            if (sentryTrace) {\n              rootSpan.setAttribute(TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL, sentryTrace);\n            }\n          }\n\n          const propagationContext = commonObjectToPropagationContext(\n            headers,\n            propagationContextFromHeaders(headersDict?.['sentry-trace'], headersDict?.['baggage']),\n          );\n\n          if (requestTraceId) {\n            propagationContext.traceId = requestTraceId;\n          }\n\n          scope.setPropagationContext(propagationContext);\n\n          return startSpanManual(\n            {\n              op: 'function.nextjs',\n              name: `${componentType}.${generationFunctionIdentifier} (${componentRoute})`,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',\n                'sentry.nextjs.ssr.function.type': generationFunctionIdentifier,\n                'sentry.nextjs.ssr.function.route': componentRoute,\n              },\n            },\n            span => {\n              return handleCallbackErrors(\n                () => originalFunction.apply(thisArg, args),\n                err => {\n                  // When you read this code you might think: \"Wait a minute, shouldn't we set the status on the root span too?\"\n                  // The answer is: \"No.\" - The status of the root span is determined by whatever status code Next.js decides to put on the response.\n                  if (isNotFoundNavigationError(err)) {\n                    // We don't want to report \"not-found\"s\n                    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });\n                    getRootSpan(span).setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });\n                  } else if (isRedirectNavigationError(err)) {\n                    // We don't want to report redirects\n                    span.setStatus({ code: SPAN_STATUS_OK });\n                  } else {\n                    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n                    getRootSpan(span).setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n                    captureException(err, {\n                      mechanism: {\n                        handled: false,\n                        type: 'auto.function.nextjs.generation_function',\n                        data: {\n                          function: generationFunctionIdentifier,\n                        },\n                      },\n                    });\n                  }\n                },\n                () => {\n                  span.end();\n                },\n              );\n            },\n          );\n        });\n      });\n    },\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1726, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/withServerActionInstrumentation.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/withServerActionInstrumentation.ts"],"sourcesContent":["import type { RequestEventData } from '@sentry/core';\nimport {\n  captureException,\n  continueTrace,\n  debug,\n  getActiveSpan,\n  getClient,\n  getIsolationScope,\n  handleCallbackErrors,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  SPAN_STATUS_ERROR,\n  startSpan,\n  withIsolationScope,\n} from '@sentry/core';\nimport { flushSafelyWithTimeout, waitUntil } from '../common/utils/responseEnd';\nimport { DEBUG_BUILD } from './debug-build';\nimport { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';\n\ninterface Options {\n  formData?: FormData;\n\n  /**\n   * Headers as returned from `headers()`.\n   *\n   * Currently accepts both a plain `Headers` object and `Promise<ReadonlyHeaders>` to be compatible with async APIs introduced in Next.js 15: https://github.com/vercel/next.js/pull/68812\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  headers?: Headers | Promise<any>;\n\n  /**\n   * Whether the server action response should be included in any events captured within the server action.\n   */\n  recordResponse?: boolean;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withServerActionInstrumentation<A extends (...args: any[]) => any>(\n  serverActionName: string,\n  callback: A,\n): Promise<ReturnType<A>>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withServerActionInstrumentation<A extends (...args: any[]) => any>(\n  serverActionName: string,\n  options: Options,\n  callback: A,\n): Promise<ReturnType<A>>;\n\n/**\n * Wraps a Next.js Server Action implementation with Sentry Error and Performance instrumentation.\n */\nexport function withServerActionInstrumentation<A extends (...args: unknown[]) => unknown>(\n  ...args: [string, Options, A] | [string, A]\n): Promise<ReturnType<A>> {\n  if (typeof args[1] === 'function') {\n    const [serverActionName, callback] = args;\n    return withServerActionInstrumentationImplementation(serverActionName, {}, callback);\n  } else {\n    const [serverActionName, options, callback] = args;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return withServerActionInstrumentationImplementation(serverActionName, options, callback!);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function withServerActionInstrumentationImplementation<A extends (...args: any[]) => any>(\n  serverActionName: string,\n  options: Options,\n  callback: A,\n): Promise<ReturnType<A>> {\n  return withIsolationScope(async isolationScope => {\n    const sendDefaultPii = getClient()?.getOptions().sendDefaultPii;\n\n    let sentryTraceHeader;\n    let baggageHeader;\n    const fullHeadersObject: Record<string, string> = {};\n    try {\n      const awaitedHeaders: Headers = await options.headers;\n      sentryTraceHeader = awaitedHeaders?.get('sentry-trace') ?? undefined;\n      baggageHeader = awaitedHeaders?.get('baggage');\n      awaitedHeaders?.forEach((value, key) => {\n        fullHeadersObject[key] = value;\n      });\n    } catch {\n      DEBUG_BUILD &&\n        debug.warn(\n          \"Sentry wasn't able to extract the tracing headers for a server action. Will not trace this request.\",\n        );\n    }\n\n    isolationScope.setTransactionName(`serverAction/${serverActionName}`);\n    isolationScope.setSDKProcessingMetadata({\n      normalizedRequest: {\n        headers: fullHeadersObject,\n      } satisfies RequestEventData,\n    });\n\n    // Normally, there is an active span here (from Next.js OTEL) and we just use that as parent\n    // Else, we manually continueTrace from the incoming headers\n    const continueTraceIfNoActiveSpan = getActiveSpan()\n      ? <T>(_opts: unknown, callback: () => T) => callback()\n      : continueTrace;\n\n    return continueTraceIfNoActiveSpan(\n      {\n        sentryTrace: sentryTraceHeader,\n        baggage: baggageHeader,\n      },\n      async () => {\n        try {\n          return await startSpan(\n            {\n              op: 'function.server_action',\n              name: `serverAction/${serverActionName}`,\n              forceTransaction: true,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.server_action',\n              },\n            },\n            async span => {\n              const result = await handleCallbackErrors(callback, error => {\n                if (isNotFoundNavigationError(error)) {\n                  // We don't want to report \"not-found\"s\n                  span.setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });\n                } else if (isRedirectNavigationError(error)) {\n                  // Don't do anything for redirects\n                } else {\n                  span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n                  captureException(error, {\n                    mechanism: {\n                      handled: false,\n                      type: 'auto.function.nextjs.server_action',\n                    },\n                  });\n                }\n              });\n\n              if (options.recordResponse !== undefined ? options.recordResponse : sendDefaultPii) {\n                getIsolationScope().setExtra('server_action_result', result);\n              }\n\n              if (options.formData) {\n                options.formData.forEach((value, key) => {\n                  getIsolationScope().setExtra(\n                    `server_action_form_data.${key}`,\n                    typeof value === 'string' ? value : '[non-string value]',\n                  );\n                });\n              }\n\n              return result;\n            },\n          );\n        } finally {\n          waitUntil(flushSafelyWithTimeout());\n        }\n      },\n    );\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1841, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/captureRequestError.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/captureRequestError.ts"],"sourcesContent":["import type { RequestEventData } from '@sentry/core';\nimport { captureException, headersToDict, withScope } from '@sentry/core';\nimport { flushSafelyWithTimeout, waitUntil } from './utils/responseEnd';\n\ntype RequestInfo = {\n  path: string;\n  method: string;\n  headers: Record<string, string | string[] | undefined>;\n};\n\ntype ErrorContext = {\n  routerKind: string; // 'Pages Router' | 'App Router'\n  routePath: string;\n  routeType: string; // 'render' | 'route' | 'middleware'\n};\n\n/**\n * Reports errors passed to the the Next.js `onRequestError` instrumentation hook.\n */\nexport function captureRequestError(error: unknown, request: RequestInfo, errorContext: ErrorContext): void {\n  withScope(scope => {\n    scope.setSDKProcessingMetadata({\n      normalizedRequest: {\n        headers: headersToDict(request.headers),\n        method: request.method,\n      } satisfies RequestEventData,\n    });\n\n    scope.setContext('nextjs', {\n      request_path: request.path,\n      router_kind: errorContext.routerKind,\n      router_path: errorContext.routePath,\n      route_type: errorContext.routeType,\n    });\n\n    scope.setTransactionName(errorContext.routePath);\n\n    captureException(error, {\n      mechanism: {\n        handled: false,\n        type: 'auto.function.nextjs.on_request_error',\n      },\n    });\n\n    waitUntil(flushSafelyWithTimeout());\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;AAgBA;;CAEA,GACO,SAAS,mBAAmB,CAAC,KAAK,EAAW,OAAO,EAAe,YAAY,EAAsB;QAC1G,sLAAS,GAAC,KAAA,IAAS;QACjB,KAAK,CAAC,wBAAwB,CAAC;YAC7B,iBAAiB,EAAE;gBACjB,OAAO,MAAE,6LAAa,EAAC,OAAO,CAAC,OAAO,CAAC;gBACvC,MAAM,EAAE,OAAO,CAAC,MAAM;YAC9B,CAAM;QACN,CAAK,CAAC;QAEF,KAAK,CAAC,UAAU,CAAC,QAAQ,EAAE;YACzB,YAAY,EAAE,OAAO,CAAC,IAAI;YAC1B,WAAW,EAAE,YAAY,CAAC,UAAU;YACpC,WAAW,EAAE,YAAY,CAAC,SAAS;YACnC,UAAU,EAAE,YAAY,CAAC,SAAS;QACxC,CAAK,CAAC;QAEF,KAAK,CAAC,kBAAkB,CAAC,YAAY,CAAC,SAAS,CAAC;YAEhD,uLAAgB,EAAC,KAAK,EAAE;YACtB,SAAS,EAAE;gBACT,OAAO,EAAE,KAAK;gBACd,IAAI,EAAE,uCAAuC;YACrD,CAAO;QACP,CAAK,CAAC;YAEF,yMAAS,MAAC,sNAAsB,EAAE,CAAC;IACrC,CAAC,CAAC;AACJ"}},
    {"offset": {"line": 1883, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/pages-router-instrumentation/_error.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/pages-router-instrumentation/_error.ts"],"sourcesContent":["import { captureException, httpRequestToRequestData, withScope } from '@sentry/core';\nimport type { NextPageContext } from 'next';\nimport { flushSafelyWithTimeout, waitUntil } from '../utils/responseEnd';\n\ntype ContextOrProps = {\n  req?: NextPageContext['req'];\n  res?: NextPageContext['res'];\n  err?: NextPageContext['err'] | string;\n  pathname?: string;\n  statusCode?: number;\n};\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nexport async function captureUnderscoreErrorException(contextOrProps: ContextOrProps): Promise<void> {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  const statusCode = res?.statusCode || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    if (req) {\n      const normalizedRequest = httpRequestToRequestData(req);\n      scope.setSDKProcessingMetadata({ normalizedRequest });\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`, {\n      mechanism: {\n        type: 'auto.function.nextjs.underscore_error',\n        handled: false,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      },\n    });\n  });\n\n  waitUntil(flushSafelyWithTimeout());\n}\n"],"names":[],"mappings":";;;;;;;;;;AAYA;;;;CAIA,GACO,eAAe,+BAA+B,CAAC,cAAc,EAAiC;IACnG,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAA,EAAI,GAAI,cAAc;IAE1C,gGAAA;IACE,MAAM,aAAa,GAAG,EAAE,UAAA,IAAc,cAAc,CAAC,UAAU;IAC/D,IAAI,UAAA,IAAc,UAAA,GAAa,GAAG,EAAE;QAClC,OAAO,OAAO,CAAC,OAAO,EAAE;IAC1B;IAEF,iHAAA;IACA,qHAAA;IACA,mHAAA;IACA,oHAAA;IACA,mHAAA;IACA,iHAAA;IACA,8EAAA;IACE,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE;QAC5B,OAAO,OAAO,CAAC,OAAO,EAAE;IAC1B;QAEA,sLAAS,GAAC,KAAA,IAAS;QACjB,IAAI,GAAG,EAAE;YACP,MAAM,iBAAA,OAAoB,wMAAwB,EAAC,GAAG,CAAC;YACvD,KAAK,CAAC,wBAAwB,CAAC;gBAAE,iBAAA;YAAA,CAAmB,CAAC;QACvD;QAEJ,kHAAA;QACA,qEAAA;YACI,uLAAgB,EAAC,GAAA,IAAO,CAAC,mCAAmC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;YACpE,SAAS,EAAE;gBACT,IAAI,EAAE,uCAAuC;gBAC7C,OAAO,EAAE,KAAK;gBACd,IAAI,EAAE;oBACJ,QAAQ,EAAE,wBAAwB;gBAC5C,CAAS;YACT,CAAO;QACP,CAAK,CAAC;IACJ,CAAC,CAAC;QAEF,yMAAS,MAAC,sNAAsB,EAAE,CAAC;AACrC"}},
    {"offset": {"line": 1941, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/isUseCacheFunction.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/isUseCacheFunction.ts"],"sourcesContent":["// Vendored from: https://github.com/vercel/next.js/blob/canary/packages/next/src/lib/client-and-server-references.ts\n\ninterface ServerReferenceInfo {\n  type: 'server-action' | 'use-cache';\n  usedArgs: [boolean, boolean, boolean, boolean, boolean, boolean];\n  hasRestArgs: boolean;\n}\n\nexport interface ServerReference {\n  $$typeof: symbol;\n  $$id: string;\n}\n\nexport type ServerFunction = ServerReference & ((...args: unknown[]) => Promise<unknown>);\n\nfunction extractInfoFromServerReferenceId(id: string): ServerReferenceInfo {\n  const infoByte = parseInt(id.slice(0, 2), 16);\n  // eslint-disable-next-line no-bitwise\n  const typeBit = (infoByte >> 7) & 0x1;\n  // eslint-disable-next-line no-bitwise\n  const argMask = (infoByte >> 1) & 0x3f;\n  // eslint-disable-next-line no-bitwise\n  const restArgs = infoByte & 0x1;\n  const usedArgs = Array(6);\n\n  for (let index = 0; index < 6; index++) {\n    const bitPosition = 5 - index;\n    // eslint-disable-next-line no-bitwise\n    const bit = (argMask >> bitPosition) & 0x1;\n    usedArgs[index] = bit === 1;\n  }\n\n  return {\n    type: typeBit === 1 ? 'use-cache' : 'server-action',\n    usedArgs: usedArgs as [boolean, boolean, boolean, boolean, boolean, boolean],\n    hasRestArgs: restArgs === 1,\n  };\n}\n\nfunction isServerReference<T>(value: T & Partial<ServerReference>): value is T & ServerFunction {\n  return value.$$typeof === Symbol.for('react.server.reference');\n}\n\n/**\n * Check if the function is a use cache function.\n *\n * @param value - The function to check.\n * @returns true if the function is a use cache function, false otherwise.\n */\nexport function isUseCacheFunction<T>(value: T & Partial<ServerReference>): value is T & ServerFunction {\n  if (!isServerReference(value)) {\n    return false;\n  }\n\n  const { type } = extractInfoFromServerReferenceId(value.$$id);\n\n  return type === 'use-cache';\n}\n"],"names":[],"mappings":"AAAA,qHAAA;;;;;AAeA,SAAS,gCAAgC,CAAC,EAAE,EAA+B;IACzE,MAAM,QAAA,GAAW,QAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;IAC/C,sCAAA;IACE,MAAM,UAAU,AAAC,YAAY,CAAC,GAAI,GAAG;IACvC,sCAAA;IACE,MAAM,UAAU,AAAC,YAAY,CAAC,GAAI,IAAI;IACxC,sCAAA;IACE,MAAM,QAAA,GAAW,QAAA,GAAW,GAAG;IAC/B,MAAM,QAAA,GAAW,KAAK,CAAC,CAAC,CAAC;IAEzB,IAAK,IAAI,KAAA,GAAQ,CAAC,EAAE,KAAA,GAAQ,CAAC,EAAE,KAAK,EAAE,CAAE;QACtC,MAAM,WAAA,GAAc,CAAA,GAAI,KAAK;QACjC,sCAAA;QACI,MAAM,MAAM,AAAC,WAAW,WAAW,GAAI,GAAG;QAC1C,QAAQ,CAAC,KAAK,CAAA,GAAI,GAAA,KAAQ,CAAC;IAC7B;IAEA,OAAO;QACL,IAAI,EAAE,OAAA,KAAY,IAAI,WAAA,GAAc,eAAe;QACnD,QAAQ,EAAE,QAAA;QACV,WAAW,EAAE,QAAA,KAAa,CAAC;IAC/B,CAAG;AACH;AAEA,SAAS,iBAAiB,CAAI,KAAK,EAA6D;IAC9F,OAAO,KAAK,CAAC,QAAA,KAAa,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC;AAChE;AAEA;;;;;CAKA,GACO,SAAS,kBAAkB,CAAI,KAAK,EAA6D;IACtG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,EAAE;QAC7B,OAAO,KAAK;IACd;IAEA,MAAM,EAAE,IAAA,EAAK,GAAI,gCAAgC,CAAC,KAAK,CAAC,IAAI,CAAC;IAE7D,OAAO,IAAA,KAAS,WAAW;AAC7B"}},
    {"offset": {"line": 1988, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/common/utils/nextSpan.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/common/utils/nextSpan.ts"],"sourcesContent":["import type { Span, StartSpanOptions } from '@sentry/core';\nimport {\n  debug,\n  SentryNonRecordingSpan,\n  startInactiveSpan as coreStartInactiveSpan,\n  startSpan as coreStartSpan,\n  startSpanManual as coreStartSpanManual,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { isBuild } from './isBuild';\nimport type { ServerReference } from './isUseCacheFunction';\nimport { isUseCacheFunction } from './isUseCacheFunction';\n\nfunction shouldNoopSpan<T>(callback?: T & Partial<ServerReference>): boolean {\n  const isBuildContext = isBuild();\n  const isUseCacheFunctionContext = callback ? isUseCacheFunction(callback) : false;\n\n  if (isUseCacheFunctionContext) {\n    DEBUG_BUILD && debug.log('Skipping span creation in Cache Components context');\n  }\n\n  return isBuildContext || isUseCacheFunctionContext;\n}\n\nfunction createNonRecordingSpan(): Span {\n  return new SentryNonRecordingSpan({\n    traceId: '00000000000000000000000000000000',\n    spanId: '0000000000000000',\n  });\n}\n\n/**\n * Next.js-specific implementation of `startSpan` that skips span creation\n * in Cache Components contexts (which render at build time).\n *\n * When in a Cache Components context, we execute the callback with a non-recording span\n * and return early without creating an actual span, since spans don't make sense at build/cache time.\n *\n * @param options - Options for starting the span\n * @param callback - Callback function that receives the span\n * @returns The return value of the callback\n */\nexport function startSpan<T>(options: StartSpanOptions, callback: (span: Span) => T): T {\n  if (shouldNoopSpan(callback)) {\n    return callback(createNonRecordingSpan());\n  }\n\n  return coreStartSpan(options, callback);\n}\n\n/**\n *\n * When in a Cache Components context, we execute the callback with a non-recording span\n * and return early without creating an actual span, since spans don't make sense at build/cache time.\n *\n * @param options - Options for starting the span\n * @param callback - Callback function that receives the span and finish function\n * @returns The return value of the callback\n */\nexport function startSpanManual<T>(options: StartSpanOptions, callback: (span: Span, finish: () => void) => T): T {\n  if (shouldNoopSpan(callback)) {\n    const nonRecordingSpan = createNonRecordingSpan();\n    return callback(nonRecordingSpan, () => nonRecordingSpan.end());\n  }\n\n  return coreStartSpanManual(options, callback);\n}\n\n/**\n *\n * When in a Cache Components context, we return a non-recording span and return early\n * without creating an actual span, since spans don't make sense at build/cache time.\n *\n * @param options - Options for starting the span\n * @returns A non-recording span (in Cache Components context) or the created span\n */\nexport function startInactiveSpan(options: StartSpanOptions): Span {\n  if (shouldNoopSpan()) {\n    return createNonRecordingSpan();\n  }\n\n  return coreStartInactiveSpan(options);\n}\n"],"names":["coreStartSpan","coreStartSpanManual","coreStartInactiveSpan"],"mappings":";;;;;;;;;;;;;;;;;;AAaA,SAAS,cAAc,CAAI,QAAQ,EAA0C;IAC3E,MAAM,cAAA,OAAiB,mMAAO,EAAE;IAChC,MAAM,yBAAA,GAA4B,QAAA,OAAW,yNAAkB,EAAC,QAAQ,CAAA,GAAI,KAAK;IAEjF,IAAI,yBAAyB,EAAE;QAC7B,qMAAA,IAAe,6LAAK,CAAC,GAAG,CAAC,oDAAoD,CAAC;IAChF;IAEA,OAAO,cAAA,IAAkB,yBAAyB;AACpD;AAEA,SAAS,sBAAsB,GAAS;IACtC,OAAO,IAAI,uNAAsB,CAAC;QAChC,OAAO,EAAE,kCAAkC;QAC3C,MAAM,EAAE,kBAAkB;IAC9B,CAAG,CAAC;AACJ;AAEA;;;;;;;;;;CAUA,GACO,SAAS,SAAS,CAAI,OAAO,EAAoB,QAAQ,EAAwB;IACtF,IAAI,cAAc,CAAC,QAAQ,CAAC,EAAE;QAC5B,OAAO,QAAQ,CAAC,sBAAsB,EAAE,CAAC;IAC3C;IAEA,WAAOA,yLAAa,EAAC,OAAO,EAAE,QAAQ,CAAC;AACzC;AAEA;;;;;;;;CAQA,GACO,SAAS,eAAe,CAAI,OAAO,EAAoB,QAAQ,EAA4C;IAChH,IAAI,cAAc,CAAC,QAAQ,CAAC,EAAE;QAC5B,MAAM,gBAAA,GAAmB,sBAAsB,EAAE;QACjD,OAAO,QAAQ,CAAC,gBAAgB,EAAE,IAAM,gBAAgB,CAAC,GAAG,EAAE,CAAC;IACjE;IAEA,WAAOC,+LAAmB,EAAC,OAAO,EAAE,QAAQ,CAAC;AAC/C;AAEA;;;;;;;CAOA,GACO,SAAS,iBAAiB,CAAC,OAAO,EAA0B;IACjE,IAAI,cAAc,EAAE,EAAE;QACpB,OAAO,sBAAsB,EAAE;IACjC;IAEA,WAAOC,iMAAqB,EAAC,OAAO,CAAC;AACvC"}},
    {"offset": {"line": 2070, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/edge/wrapApiHandlerWithSentry.js","sources":["turbopack:///[project]/node_modules/@sentry/nextjs/src/edge/wrapApiHandlerWithSentry.ts"],"sourcesContent":["import {\n  captureException,\n  getActiveSpan,\n  getCurrentScope,\n  getRootSpan,\n  handleCallbackErrors,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setCapturedScopesOnSpan,\n  startSpan,\n  winterCGRequestToRequestData,\n  withIsolationScope,\n} from '@sentry/core';\nimport { addHeadersAsAttributes } from '../common/utils/addHeadersAsAttributes';\nimport { flushSafelyWithTimeout, waitUntil } from '../common/utils/responseEnd';\nimport type { EdgeRouteHandler } from './types';\n\n/**\n * Wraps a Next.js edge route handler with Sentry error and performance instrumentation.\n */\nexport function wrapApiHandlerWithSentry<H extends EdgeRouteHandler>(\n  handler: H,\n  parameterizedRoute: string,\n): (...params: Parameters<H>) => Promise<ReturnType<H>> {\n  return new Proxy(handler, {\n    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {\n      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.\n\n      return withIsolationScope(isolationScope => {\n        const req: unknown = args[0];\n        const currentScope = getCurrentScope();\n\n        let headerAttributes: Record<string, string> = {};\n\n        if (req instanceof Request) {\n          isolationScope.setSDKProcessingMetadata({\n            normalizedRequest: winterCGRequestToRequestData(req),\n          });\n          currentScope.setTransactionName(`${req.method} ${parameterizedRoute}`);\n          headerAttributes = addHeadersAsAttributes(req.headers);\n        } else {\n          currentScope.setTransactionName(`handler (${parameterizedRoute})`);\n        }\n\n        let spanName: string;\n        let op: string | undefined = 'http.server';\n\n        // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can\n        // rely on that for parameterization.\n        const activeSpan = getActiveSpan();\n        if (activeSpan) {\n          spanName = `handler (${parameterizedRoute})`;\n          op = undefined;\n\n          const rootSpan = getRootSpan(activeSpan);\n          if (rootSpan) {\n            rootSpan.updateName(\n              req instanceof Request ? `${req.method} ${parameterizedRoute}` : `handler ${parameterizedRoute}`,\n            );\n            rootSpan.setAttributes({\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n              ...headerAttributes,\n            });\n            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);\n          }\n        } else if (req instanceof Request) {\n          spanName = `${req.method} ${parameterizedRoute}`;\n        } else {\n          spanName = `handler ${parameterizedRoute}`;\n        }\n\n        return startSpan(\n          {\n            name: spanName,\n            op: op,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrap_api_handler',\n              ...headerAttributes,\n            },\n          },\n          () => {\n            return handleCallbackErrors(\n              () => wrappingTarget.apply(thisArg, args),\n              error => {\n                captureException(error, {\n                  mechanism: {\n                    type: 'auto.function.nextjs.wrap_api_handler',\n                    handled: false,\n                  },\n                });\n              },\n              () => {\n                waitUntil(flushSafelyWithTimeout());\n              },\n            );\n          },\n        );\n      });\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAkBA;;CAEA,GACO,SAAS,wBAAwB,CACtC,OAAO,EACP,kBAAkB;IAElB,OAAO,IAAI,KAAK,CAAC,OAAO,EAAE;QACxB,KAAK,EAAE,OAAO,cAAc,EAAE,OAAO,EAAE,IAAI,KAAoB;YACnE,2IAAA;YAEM,WAAO,+LAAkB,GAAC,cAAA,IAAkB;gBAC1C,MAAM,GAAG,GAAY,IAAI,CAAC,CAAC,CAAC;gBAC5B,MAAM,YAAA,OAAe,4LAAe,EAAE;gBAEtC,IAAI,gBAAgB,GAA2B,CAAA,CAAE;gBAEjD,IAAI,GAAA,YAAe,OAAO,EAAE;oBAC1B,cAAc,CAAC,wBAAwB,CAAC;wBACtC,iBAAiB,MAAE,4MAA4B,EAAC,GAAG,CAAC;oBAChE,CAAW,CAAC;oBACF,YAAY,CAAC,kBAAkB,CAAC,CAAC,EAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,kBAAA,CAAA,CAAA,CAAA;oBACA,gBAAA,OAAA,iOAAA,EAAA,GAAA,CAAA,OAAA,CAAA;gBACA,CAAA,MAAA;oBACA,YAAA,CAAA,kBAAA,CAAA,CAAA,SAAA,EAAA,kBAAA,CAAA,CAAA,CAAA,CAAA;gBACA;gBAEA,IAAA,QAAA;gBACA,IAAA,EAAA,GAAA,aAAA;gBAEA,gHAAA;gBACA,qCAAA;gBACA,MAAA,UAAA,OAAA,+LAAA,EAAA;gBACA,IAAA,UAAA,EAAA;oBACA,QAAA,GAAA,CAAA,SAAA,EAAA,kBAAA,CAAA,CAAA,CAAA;oBACA,EAAA,GAAA,SAAA;oBAEA,MAAA,QAAA,OAAA,6LAAA,EAAA,UAAA,CAAA;oBACA,IAAA,QAAA,EAAA;wBACA,QAAA,CAAA,UAAA,CACA,GAAA,YAAA,OAAA,GAAA,CAAA,EAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,kBAAA,CAAA,CAAA,GAAA,CAAA,QAAA,EAAA,kBAAA,CAAA,CAAA;wBAEA,QAAA,CAAA,aAAA,CAAA;4BACA,CAAA,8MAAA,CAAA,EAAA,aAAA;4BACA,CAAA,kNAAA,CAAA,EAAA,OAAA;4BACA,GAAA,gBAAA;wBACA,CAAA,CAAA;4BACA,uMAAA,EAAA,QAAA,EAAA,YAAA,EAAA,cAAA,CAAA;oBACA;gBACA,CAAA,MAAA,IAAA,GAAA,YAAA,OAAA,EAAA;oBACA,QAAA,GAAA,CAAA,EAAA,GAAA,CAAA,MAAA,CAAA,CAAA,EAAA,kBAAA,CAAA,CAAA;gBACA,CAAA,MAAA;oBACA,QAAA,GAAA,CAAA,QAAA,EAAA,kBAAA,CAAA,CAAA;gBACA;gBAEA,WAAA,yLAAA,EACA;oBACA,IAAA,EAAA,QAAA;oBACA,EAAA,EAAA,EAAA;oBACA,UAAA,EAAA;wBACA,CAAA,kNAAA,CAAA,EAAA,OAAA;wBACA,CAAA,kNAAA,CAAA,EAAA,uCAAA;wBACA,GAAA,gBAAA;oBACA,CAAA;gBACA,CAAA,EACA,MAAA;oBACA,WAAA,iNAAA,EACA,IAAA,cAAA,CAAA,KAAA,CAAA,OAAA,EAAA,IAAA,CAAA,GACA,KAAA,IAAA;4BACA,uLAAA,EAAA,KAAA,EAAA;4BACA,SAAA,EAAA;gCACA,IAAA,EAAA,uCAAA;gCACA,OAAA,EAAA,KAAA;4BACA,CAAA;wBACA,CAAA,CAAA;oBACA,CAAA,EACA,MAAA;4BACA,yMAAA,MAAA,sNAAA,EAAA,CAAA;oBACA,CAAA;gBAEA,CAAA;YAEA,CAAA,CAAA;QACA,CAAA;IACA,CAAA,CAAA;AACA"}}]
}