{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/env.ts"],"sourcesContent":["// lib/env.ts\n// Environment variable validation and access\n\nconst isServer = typeof window === \"undefined\";\n\n/**\n * Validates that all required environment variables are present\n * Only validates on the server (fail-fast)\n * On client, variables should be embedded at build time\n */\nfunction validateEnv() {\n  // Server-side variables (only available on server)\n  const serverRequired = [\n    'SUPABASE_SERVICE_ROLE_KEY',\n    'CSRF_SECRET',\n  ] as const;\n\n  // Only validate server-side variables on the server\n  if (isServer) {\n    const missing: string[] = [];\n    \n    // Validate server-side variables\n    for (const key of serverRequired) {\n      if (!process.env[key]) {\n        missing.push(key);\n      }\n    }\n\n    // Also validate client-side variables on server (they should be available)\n    const clientRequired = [\n      'NEXT_PUBLIC_SUPABASE_URL',\n      'NEXT_PUBLIC_SUPABASE_ANON_KEY',\n    ] as const;\n    \n    for (const key of clientRequired) {\n      if (!process.env[key]) {\n        missing.push(key);\n      }\n    }\n\n    if (missing.length > 0) {\n      throw new Error(\n        `Missing required environment variables: ${missing.join(', ')}\\n` +\n        'Please check your .env.local file or environment configuration.'\n      );\n    }\n  }\n  // On client, we don't validate here - variables should be embedded at build time\n  // If they're missing, we'll get undefined values which will cause errors at usage time\n}\n\n// Validate on module load (server-side only)\nvalidateEnv();\n\n/**\n * Validated environment variables\n * Note: On client, NEXT_PUBLIC_* variables are embedded at build time\n * If they're missing, they'll be undefined (which will cause errors at usage)\n */\nexport const env = {\n  // Client-side variables (embedded at build time)\n  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL || '',\n  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '',\n  // Server-side variable - only available on server\n  SUPABASE_SERVICE_ROLE_KEY: (isServer ? (process.env.SUPABASE_SERVICE_ROLE_KEY || '') : '') as string,\n} as const;\n\n"],"names":[],"mappings":"AAAA,aAAa;AACb,6CAA6C;;;;;AAE7C,MAAM,WAAW,kDAAkB;AAEnC;;;;CAIC,GACD,SAAS;IACP,mDAAmD;IACnD,MAAM,iBAAiB;QACrB;QACA;KACD;IAED,oDAAoD;IACpD,wCAAc;QACZ,MAAM,UAAoB,EAAE;QAE5B,iCAAiC;QACjC,KAAK,MAAM,OAAO,eAAgB;YAChC,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,EAAE;gBACrB,QAAQ,IAAI,CAAC;YACf;QACF;QAEA,2EAA2E;QAC3E,MAAM,iBAAiB;YACrB;YACA;SACD;QAED,KAAK,MAAM,OAAO,eAAgB;YAChC,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,EAAE;gBACrB,QAAQ,IAAI,CAAC;YACf;QACF;QAEA,IAAI,QAAQ,MAAM,GAAG,GAAG;YACtB,MAAM,IAAI,MACR,CAAC,wCAAwC,EAAE,QAAQ,IAAI,CAAC,MAAM,EAAE,CAAC,GACjE;QAEJ;IACF;AACA,iFAAiF;AACjF,uFAAuF;AACzF;AAEA,6CAA6C;AAC7C;AAOO,MAAM,MAAM;IACjB,iDAAiD;IACjD,0BAA0B,QAAQ,GAAG,CAAC,wBAAwB,IAAI;IAClE,+BAA+B,QAAQ,GAAG,CAAC,6BAA6B,IAAI;IAC5E,kDAAkD;IAClD,2BAA4B,uCAAY,QAAQ,GAAG,CAAC,yBAAyB,IAAI,KAAM;AACzF"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/request-context.ts"],"sourcesContent":["// lib/request-context.ts\n// Request context for correlation IDs and request tracking\n\n// Note: AsyncLocalStorage is only available in Node.js, not Edge runtime\n// For Edge runtime (middleware), we use a simpler approach with request headers\nlet asyncLocalStorage: any = null;\n\ntry {\n  // Try to import AsyncLocalStorage (Node.js only)\n  if (typeof require !== \"undefined\") {\n    const { AsyncLocalStorage } = require(\"async_hooks\");\n    asyncLocalStorage = new AsyncLocalStorage();\n  }\n} catch {\n  // AsyncLocalStorage not available (Edge runtime)\n  asyncLocalStorage = null;\n}\n\n/**\n * Request context data\n */\nexport interface RequestContext {\n  requestId: string;\n  userId?: string;\n  ip?: string;\n  userAgent?: string;\n  startTime: number;\n  method?: string;\n  path?: string;\n}\n\n/**\n * AsyncLocalStorage for request context\n * This allows us to access request context anywhere in the request lifecycle\n */\nconst requestContextStorage = new AsyncLocalStorage<RequestContext>();\n\n/**\n * Get the current request context\n * @returns Request context or null if not in a request\n */\nexport function getRequestContext(): RequestContext | null {\n  if (!asyncLocalStorage) {\n    return null; // Edge runtime - context not available\n  }\n  return asyncLocalStorage.getStore() || null;\n}\n\n/**\n * Get the current request ID\n * @returns Request ID or null\n */\nexport function getRequestId(): string | null {\n  const context = getRequestContext();\n  return context?.requestId || null;\n}\n\n/**\n * Run a function with request context\n * @param context - Request context\n * @param fn - Function to run\n * @returns Result of the function\n */\nexport function withRequestContext<T>(context: RequestContext, fn: () => T): T {\n  if (!asyncLocalStorage) {\n    // Edge runtime - just run the function without context\n    return fn();\n  }\n  return asyncLocalStorage.run(context, fn);\n}\n\n/**\n * Generate a unique request ID\n * @returns Request ID\n */\nexport function generateRequestId(): string {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 9).toUpperCase();\n  return `REQ-${timestamp}-${random}`;\n}\n\n/**\n * Create a new request context\n * @param options - Context options\n * @returns Request context\n */\nexport function createRequestContext(options: {\n  requestId?: string;\n  userId?: string;\n  ip?: string;\n  userAgent?: string;\n  method?: string;\n  path?: string;\n}): RequestContext {\n  return {\n    requestId: options.requestId || generateRequestId(),\n    userId: options.userId,\n    ip: options.ip,\n    userAgent: options.userAgent,\n    startTime: Date.now(),\n    method: options.method,\n    path: options.path,\n  };\n}\n\n"],"names":[],"mappings":"AAAA,yBAAyB;AACzB,2DAA2D;AAE3D,yEAAyE;AACzE,gFAAgF;;;;;;;;;;;;;AAChF,IAAI,oBAAyB;AAE7B,IAAI;IACF,iDAAiD;IACjD,wCAAoC;QAClC,MAAM,EAAE,mBAAA,kBAAiB,EAAE;QAC3B,oBAAoB,IAAI;IAC1B;AACF,EAAE,OAAM;IACN,iDAAiD;IACjD,oBAAoB;AACtB;AAeA;;;CAGC,GACD,MAAM,wBAAwB,IAAI;AAM3B,SAAS;IACd,IAAI,CAAC,mBAAmB;QACtB,OAAO,MAAM,uCAAuC;IACtD;IACA,OAAO,kBAAkB,QAAQ,MAAM;AACzC;AAMO,SAAS;IACd,MAAM,UAAU;IAChB,OAAO,SAAS,aAAa;AAC/B;AAQO,SAAS,mBAAsB,OAAuB,EAAE,EAAW;IACxE,IAAI,CAAC,mBAAmB;QACtB,uDAAuD;QACvD,OAAO;IACT;IACA,OAAO,kBAAkB,GAAG,CAAC,SAAS;AACxC;AAMO,SAAS;IACd,MAAM,YAAY,KAAK,GAAG;IAC1B,MAAM,SAAS,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,GAAG,WAAW;IACrE,OAAO,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE,QAAQ;AACrC;AAOO,SAAS,qBAAqB,OAOpC;IACC,OAAO;QACL,WAAW,QAAQ,SAAS,IAAI;QAChC,QAAQ,QAAQ,MAAM;QACtB,IAAI,QAAQ,EAAE;QACd,WAAW,QAAQ,SAAS;QAC5B,WAAW,KAAK,GAAG;QACnB,QAAQ,QAAQ,MAAM;QACtB,MAAM,QAAQ,IAAI;IACpB;AACF"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/log-sanitizer.ts"],"sourcesContent":["// lib/log-sanitizer.ts\n// PII (Personally Identifiable Information) sanitization for logs\n\n/**\n * Sensitive fields that should be redacted from logs\n */\nconst SENSITIVE_FIELDS = [\n  \"password\",\n  \"passwd\",\n  \"pwd\",\n  \"secret\",\n  \"token\",\n  \"api_key\",\n  \"apikey\",\n  \"access_token\",\n  \"refresh_token\",\n  \"authorization\",\n  \"auth\",\n  \"credit_card\",\n  \"cc_number\",\n  \"card_number\",\n  \"cvv\",\n  \"cvc\",\n  \"ssn\",\n  \"social_security\",\n  \"ssn_number\",\n  \"phone\",\n  \"mobile\",\n  \"telephone\",\n  \"email\",\n  \"email_address\",\n] as const;\n\n/**\n * Patterns to detect and redact sensitive data\n */\nconst SENSITIVE_PATTERNS = [\n  /password[\"\\s:=]+([^\"}\\s,]+)/gi,\n  /token[\"\\s:=]+([^\"}\\s,]+)/gi,\n  /secret[\"\\s:=]+([^\"}\\s,]+)/gi,\n  /api[_-]?key[\"\\s:=]+([^\"}\\s,]+)/gi,\n  /authorization[\"\\s:=]+([^\"}\\s,]+)/gi,\n  /bearer\\s+([a-zA-Z0-9._-]+)/gi,\n  /\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b/g, // Credit card\n  /\\b\\d{3}-\\d{2}-\\d{4}\\b/g, // SSN\n  /\\b\\d{3}\\.\\d{2}\\.\\d{4}\\b/g, // SSN with dots\n] as const;\n\n/**\n * Hash an email address for logging (one-way hash)\n * @param email - Email address to hash\n * @returns Hashed email (first 3 chars + hash)\n */\nexport function hashEmail(email: string): string {\n  if (!email || typeof email !== \"string\") {\n    return \"[invalid]\";\n  }\n\n  const [localPart, domain] = email.split(\"@\");\n  if (!localPart || !domain) {\n    return \"[invalid]\";\n  }\n\n  // Show first 3 characters of local part, hash the rest\n  const visiblePart = localPart.substring(0, 3);\n  const hash = simpleHash(localPart + domain);\n  return `${visiblePart}***@${domain}`;\n}\n\n/**\n * Simple hash function for email hashing\n */\nfunction simpleHash(str: string): string {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(36).substring(0, 6);\n}\n\n/**\n * Mask phone number (show last 4 digits only)\n */\nexport function maskPhone(phone: string): string {\n  if (!phone || typeof phone !== \"string\") {\n    return \"[invalid]\";\n  }\n\n  const digits = phone.replace(/\\D/g, \"\");\n  if (digits.length < 4) {\n    return \"***\";\n  }\n\n  return `***-***-${digits.slice(-4)}`;\n}\n\n/**\n * Redact sensitive fields from an object\n * @param obj - Object to sanitize\n * @param depth - Current depth (to prevent infinite recursion)\n * @returns Sanitized object\n */\nexport function sanitizeObject(obj: any, depth: number = 0): any {\n  if (depth > 10) {\n    return \"[max depth reached]\";\n  }\n\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  if (typeof obj !== \"object\") {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => sanitizeObject(item, depth + 1));\n  }\n\n  const sanitized: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const lowerKey = key.toLowerCase();\n\n    // Check if field is sensitive\n    if (SENSITIVE_FIELDS.some((field) => lowerKey.includes(field))) {\n      if (typeof value === \"string\") {\n        // Special handling for emails\n        if (lowerKey.includes(\"email\")) {\n          sanitized[key] = hashEmail(value);\n        } else if (lowerKey.includes(\"phone\") || lowerKey.includes(\"mobile\")) {\n          sanitized[key] = maskPhone(value);\n        } else {\n          sanitized[key] = \"[REDACTED]\";\n        }\n      } else {\n        sanitized[key] = \"[REDACTED]\";\n      }\n    } else if (typeof value === \"object\" && value !== null) {\n      // Recursively sanitize nested objects\n      sanitized[key] = sanitizeObject(value, depth + 1);\n    } else {\n      sanitized[key] = value;\n    }\n  }\n\n  return sanitized;\n}\n\n/**\n * Sanitize a string by redacting sensitive patterns\n * @param str - String to sanitize\n * @returns Sanitized string\n */\nexport function sanitizeString(str: string): string {\n  if (!str || typeof str !== \"string\") {\n    return str;\n  }\n\n  let sanitized = str;\n\n  // Replace sensitive patterns\n  for (const pattern of SENSITIVE_PATTERNS) {\n    sanitized = sanitized.replace(pattern, (match) => {\n      if (match.length > 20) {\n        return match.substring(0, 10) + \"***[REDACTED]\";\n      }\n      return \"[REDACTED]\";\n    });\n  }\n\n  return sanitized;\n}\n\n/**\n * Sanitize request/response body for logging\n * @param body - Request or response body\n * @returns Sanitized body\n */\nexport function sanitizeBody(body: any): any {\n  if (!body) {\n    return body;\n  }\n\n  if (typeof body === \"string\") {\n    try {\n      const parsed = JSON.parse(body);\n      return sanitizeObject(parsed);\n    } catch {\n      return sanitizeString(body);\n    }\n  }\n\n  if (typeof body === \"object\") {\n    return sanitizeObject(body);\n  }\n\n  return body;\n}\n\n/**\n * Sanitize headers for logging\n * @param headers - Headers object\n * @returns Sanitized headers\n */\nexport function sanitizeHeaders(headers: Record<string, string>): Record<string, string> {\n  const sanitized: Record<string, string> = {};\n\n  for (const [key, value] of Object.entries(headers)) {\n    const lowerKey = key.toLowerCase();\n\n    // Redact sensitive headers\n    if (\n      lowerKey.includes(\"authorization\") ||\n      lowerKey.includes(\"cookie\") ||\n      lowerKey.includes(\"x-api-key\") ||\n      lowerKey.includes(\"x-csrf-token\")\n    ) {\n      sanitized[key] = \"[REDACTED]\";\n    } else {\n      sanitized[key] = value;\n    }\n  }\n\n  return sanitized;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/logger.ts"],"sourcesContent":["// lib/logger.ts\n// Enhanced structured logging with PII sanitization and request context\n\nimport * as Sentry from \"@sentry/nextjs\";\nimport { getRequestContext } from \"./request-context\";\nimport { sanitizeObject, sanitizeString, sanitizeBody } from \"./log-sanitizer\";\n\nexport enum LogLevel {\n  DEBUG = \"DEBUG\",\n  INFO = \"INFO\",\n  WARN = \"WARN\",\n  ERROR = \"ERROR\",\n}\n\ninterface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  requestId?: string | null;\n  userId?: string;\n  [key: string]: any;\n}\n\nconst isDevelopment = process.env.NODE_ENV === \"development\";\nconst isProduction = process.env.NODE_ENV === \"production\";\n\n/**\n * Log sampling configuration\n * In production, log 100% of errors, but sample other logs\n */\nconst LOG_SAMPLING = {\n  [LogLevel.DEBUG]: isDevelopment ? 1.0 : 0.0, // No debug logs in production\n  [LogLevel.INFO]: isDevelopment ? 1.0 : 0.1, // 10% of info logs in production\n  [LogLevel.WARN]: isDevelopment ? 1.0 : 0.5, // 50% of warnings in production\n  [LogLevel.ERROR]: 1.0, // 100% of errors always\n};\n\n/**\n * Check if a log entry should be logged based on sampling\n */\nfunction shouldLog(level: LogLevel): boolean {\n  const sampleRate = LOG_SAMPLING[level];\n  return Math.random() < sampleRate;\n}\n\n/**\n * Format log entry for output\n */\nfunction formatLogEntry(entry: LogEntry): string {\n  const context = getRequestContext();\n  \n  // Add request context if available\n  if (context) {\n    entry.requestId = context.requestId;\n    if (context.userId) {\n      entry.userId = context.userId;\n    }\n  }\n\n  if (isDevelopment) {\n    // Pretty format for development\n    const prefix = `[${entry.timestamp}] [${entry.level}]`;\n    const contextStr = entry.requestId ? `[${entry.requestId}]` : \"\";\n    const message = entry.message;\n    const extra = Object.keys(entry)\n      .filter((key) => ![\"timestamp\", \"level\", \"message\", \"requestId\", \"userId\"].includes(key))\n      .map((key) => `${key}=${JSON.stringify(entry[key])}`)\n      .join(\" \");\n\n    return `${prefix} ${contextStr} ${message} ${extra}`.trim();\n  } else {\n    // JSON format for production\n    return JSON.stringify(entry);\n  }\n}\n\n/**\n * Enhanced logger with structured logging\n */\nexport const logger = {\n  /**\n   * Debug logs - only in development\n   */\n  debug: (message: string, ...args: unknown[]): void => {\n    if (!shouldLog(LogLevel.DEBUG)) return;\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: LogLevel.DEBUG,\n      message: sanitizeString(message),\n    };\n\n    // Sanitize additional arguments\n    if (args.length > 0) {\n      entry.data = sanitizeObject(args.length === 1 ? args[0] : args);\n    }\n\n    console.log(formatLogEntry(entry));\n  },\n\n  /**\n   * Info logs\n   */\n  info: (message: string, ...args: unknown[]): void => {\n    if (!shouldLog(LogLevel.INFO)) return;\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: LogLevel.INFO,\n      message: sanitizeString(message),\n    };\n\n    if (args.length > 0) {\n      entry.data = sanitizeObject(args.length === 1 ? args[0] : args);\n    }\n\n    console.info(formatLogEntry(entry));\n  },\n\n  /**\n   * Warning logs - sent to Sentry as breadcrumb\n   */\n  warn: (message: string, ...args: unknown[]): void => {\n    if (!shouldLog(LogLevel.WARN)) return;\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: LogLevel.WARN,\n      message: sanitizeString(message),\n    };\n\n    if (args.length > 0) {\n      entry.data = sanitizeObject(args.length === 1 ? args[0] : args);\n    }\n\n    console.warn(formatLogEntry(entry));\n\n    // Add warning as breadcrumb to Sentry\n    try {\n      Sentry.addBreadcrumb({\n        level: \"warning\",\n        message: sanitizeString(message),\n        data: args.length > 0 ? sanitizeObject(args.length === 1 ? args[0] : args) : undefined,\n      });\n    } catch {\n      // Silently fail if Sentry is not initialized\n    }\n  },\n\n  /**\n   * Error logs - always logged, sent to Sentry\n   */\n  error: (message: string, ...args: unknown[]): void => {\n    if (!shouldLog(LogLevel.ERROR)) return;\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: LogLevel.ERROR,\n      message: sanitizeString(message),\n    };\n\n    // Extract error object if present\n    const error = args.find((arg) => arg instanceof Error) as Error | undefined;\n    if (error) {\n      entry.error = {\n        name: error.name,\n        message: error.message,\n        stack: isDevelopment ? error.stack : undefined,\n      };\n    }\n\n    // Sanitize other arguments\n    const otherArgs = args.filter((arg) => !(arg instanceof Error));\n    if (otherArgs.length > 0) {\n      entry.data = sanitizeObject(otherArgs.length === 1 ? otherArgs[0] : otherArgs);\n    }\n\n    console.error(formatLogEntry(entry));\n\n    // Send error to Sentry\n    try {\n      if (error) {\n        Sentry.captureException(error, {\n          level: \"error\",\n          extra: {\n            message: sanitizeString(message),\n            data: otherArgs.length > 0 ? sanitizeObject(otherArgs.length === 1 ? otherArgs[0] : otherArgs) : undefined,\n          },\n        });\n      } else {\n        const fullMessage = [message, ...otherArgs.map((arg) => String(arg))].join(\" \");\n        Sentry.captureMessage(sanitizeString(fullMessage), {\n          level: \"error\",\n          extra: {\n            data: otherArgs.length > 0 ? sanitizeObject(otherArgs.length === 1 ? otherArgs[0] : otherArgs) : undefined,\n          },\n        });\n      }\n    } catch {\n      // Silently fail if Sentry is not initialized\n    }\n  },\n\n  /**\n   * Log a request\n   */\n  request: (data: {\n    method: string;\n    path: string;\n    statusCode: number;\n    duration: number;\n    ip?: string;\n    userAgent?: string;\n    userId?: string;\n    requestSize?: number;\n    responseSize?: number;\n    error?: Error;\n  }): void => {\n    const context = getRequestContext();\n    const level = data.statusCode >= 500 ? LogLevel.ERROR : data.statusCode >= 400 ? LogLevel.WARN : LogLevel.INFO;\n\n    if (!shouldLog(level)) return;\n\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message: `${data.method} ${data.path} ${data.statusCode}`,\n      method: data.method,\n      path: data.path,\n      statusCode: data.statusCode,\n      duration: data.duration,\n      requestId: context?.requestId,\n    };\n\n    if (data.ip) {\n      entry.ip = data.ip;\n    }\n\n    if (data.userAgent) {\n      entry.userAgent = data.userAgent;\n    }\n\n    if (data.userId) {\n      entry.userId = data.userId;\n    }\n\n    if (data.requestSize !== undefined) {\n      entry.requestSize = data.requestSize;\n    }\n\n    if (data.responseSize !== undefined) {\n      entry.responseSize = data.responseSize;\n    }\n\n    if (data.error) {\n      entry.error = {\n        name: data.error.name,\n        message: data.error.message,\n        stack: isDevelopment ? data.error.stack : undefined,\n      };\n    }\n\n    // Log slow requests as warnings\n    if (data.duration > 5000) {\n      entry.level = LogLevel.ERROR;\n      entry.message += \" [VERY SLOW]\";\n    } else if (data.duration > 1000) {\n      entry.level = LogLevel.WARN;\n      entry.message += \" [SLOW]\";\n    }\n\n    const logFn = level === LogLevel.ERROR ? console.error : level === LogLevel.WARN ? console.warn : console.info;\n    logFn(formatLogEntry(entry));\n  },\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 544, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/instrumentation/server.ts"],"sourcesContent":["// lib/instrumentation/server.ts\n// Server-side Sentry instrumentation for API and database tracking\n// NOTE: This file should only be imported in Node.js runtime (API routes, not middleware)\n\n// Conditional import to avoid Edge Runtime issues\nlet Sentry: typeof import(\"@sentry/nextjs\") | null = null;\n\nasync function getSentry() {\n  if (!Sentry && typeof window === \"undefined\") {\n    try {\n      Sentry = await import(\"@sentry/nextjs\");\n    } catch (error) {\n      // Sentry not available (e.g., in test environment)\n      return null;\n    }\n  }\n  return Sentry;\n}\n\n/**\n * Track API route performance\n * Wraps an API route handler to automatically track performance\n */\nexport function withApiPerformanceTracking<T extends (...args: any[]) => Promise<any>>(\n  handler: T,\n  routeName: string\n): T {\n  return (async (...args: Parameters<T>) => {\n    const sentry = await getSentry();\n    if (!sentry) {\n      // Sentry not available, just run handler\n      return handler(...args);\n    }\n    \n    // Use startSpan instead of deprecated startTransaction\n    return sentry.startSpan(\n      {\n        name: routeName,\n        op: \"http.server\",\n        attributes: {\n          route: routeName,\n        },\n      },\n      async (span) => {\n        try {\n          const result = await handler(...args);\n          span?.setStatus({ code: 1, message: \"ok\" }); // 1 = OK\n          return result;\n        } catch (error) {\n          span?.setStatus({ code: 2, message: \"internal_error\" }); // 2 = ERROR\n          throw error;\n        }\n      }\n    );\n  }) as T;\n}\n\n/**\n * Track database query performance\n * Wraps a database operation to track its performance\n */\nexport async function trackDatabaseQuery<T>(\n  operation: () => Promise<T>,\n  operationName: string,\n  tableName?: string\n): Promise<T> {\n  const sentry = await getSentry();\n  if (!sentry) {\n    // Sentry not available, just run operation\n    return operation();\n  }\n  \n  const span = sentry.startSpan(\n    {\n      op: \"db.query\",\n      name: operationName,\n      attributes: {\n        table: tableName,\n        operation: operationName,\n      },\n    },\n    async () => {\n      try {\n        const result = await operation();\n        return result;\n      } catch (error) {\n        sentry.captureException(error, {\n          tags: {\n            operation: operationName,\n            table: tableName || \"unknown\",\n            error_type: \"database_error\",\n          },\n        });\n        throw error;\n      }\n    }\n  );\n\n  return span as T;\n}\n\n/**\n * Track RPC function calls\n */\nexport async function trackRpcCall<T extends { data: any; error: any }>(\n  rpcFunction: () => Promise<T>,\n  functionName: string,\n  params?: Record<string, any>\n): Promise<T> {\n  const sentry = await getSentry();\n  if (!sentry) {\n    // Sentry not available, just run function\n    return rpcFunction();\n  }\n  \n  return sentry.startSpan(\n    {\n      op: \"db.rpc\",\n      name: functionName,\n      attributes: {\n        function: functionName,\n        params: params ? JSON.stringify(params) : undefined,\n      },\n    },\n    async () => {\n      try {\n        const result = await rpcFunction();\n        return result;\n      } catch (error) {\n        sentry.captureException(error, {\n          tags: {\n            function: functionName,\n            error_type: \"rpc_error\",\n          },\n          extra: {\n            params,\n          },\n        });\n        throw error;\n      }\n    }\n  ) as Promise<T>;\n}\n\n/**\n * Track registration approval/rejection events\n */\nexport async function trackRegistrationEvent(\n  eventType: \"approve\" | \"reject\",\n  registrationId: string,\n  adminUserId: string,\n  success: boolean,\n  error?: Error\n) {\n  try {\n    const sentry = await getSentry();\n    if (!sentry) {\n      return; // Sentry not available\n    }\n    \n    sentry.addBreadcrumb({\n      category: \"registration\",\n      message: `Registration ${eventType}: ${registrationId}`,\n      level: success ? \"info\" : \"error\",\n      data: {\n        event_type: eventType,\n        registration_id: registrationId,\n        admin_user_id: adminUserId,\n        success,\n      },\n    });\n\n    if (!success && error) {\n      sentry.captureException(error, {\n        tags: {\n          event_type: eventType,\n          operation: \"registration_management\",\n        },\n        extra: {\n          registration_id: registrationId,\n          admin_user_id: adminUserId,\n        },\n      });\n    }\n  } catch (err) {\n    // Silently fail if Sentry is not initialized\n    // This can happen in test environments or if Sentry is not configured\n  }\n}\n\n/**\n * Track authentication failures\n */\nexport async function trackAuthFailure(\n  reason: string,\n  userId?: string,\n  email?: string\n) {\n  try {\n    const sentry = await getSentry();\n    if (!sentry) {\n      return; // Sentry not available\n    }\n    \n    sentry.addBreadcrumb({\n      category: \"auth\",\n      message: `Authentication failure: ${reason}`,\n      level: \"warning\",\n      data: {\n        reason,\n        user_id: userId,\n        email,\n      },\n    });\n\n    // Don't send to Sentry as an error (expected behavior)\n    // Just log as breadcrumb for context\n  } catch (error) {\n    // Silently fail if Sentry is not initialized\n    // This can happen in test environments or if Sentry is not configured\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 726, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/auth.ts"],"sourcesContent":["// lib/auth.ts\n// Shared authentication and authorization utilities\n\nimport { createServerClient } from \"@supabase/ssr\";\nimport { cookies } from \"next/headers\";\nimport { NextRequest } from \"next/server\";\nimport { env } from \"./env\";\nimport { logger } from \"./logger\";\nimport type { AdminUser, AdminCheckResult } from \"@/types/auth\";\nimport { trackAuthFailure } from \"./instrumentation/server\";\n\n/**\n * Check if a user has admin privileges\n * @param user - Supabase user object\n * @returns true if user is an admin\n */\nexport function isAdminUser(user: AdminUser | null | undefined): boolean {\n  if (!user) return false;\n  \n  const roles = (user.app_metadata?.roles ?? user.user_metadata?.roles ?? []) as string[];\n  const role = (user.app_metadata?.role ?? user.user_metadata?.role) as string | undefined;\n  return roles?.includes(\"admin\") || role === \"admin\" || user.user_metadata?.is_admin === true;\n}\n\n/**\n * Check if the current request is from an authenticated admin user\n * @param req - Next.js request object\n * @returns Object with isAdmin boolean and user object (or null)\n */\nexport async function checkAdmin(req: NextRequest): Promise<AdminCheckResult> {\n  try {\n    const cookieStore = await cookies();\n    const supabase = createServerClient(\n      env.NEXT_PUBLIC_SUPABASE_URL,\n      env.NEXT_PUBLIC_SUPABASE_ANON_KEY,\n      {\n        cookies: {\n          getAll() {\n            return cookieStore.getAll();\n          },\n          setAll(cookiesToSet) {\n            try {\n              cookiesToSet.forEach(({ name, value, options }) =>\n                cookieStore.set(name, value, options)\n              );\n            } catch (err) {\n              // Ignore cookie setting errors in API routes\n              logger.warn(\"Cookie set error:\", err);\n            }\n          },\n        },\n      }\n    );\n\n    const { data: { user }, error } = await supabase.auth.getUser();\n    \n    if (error || !user) {\n      // Fire and forget - don't await to avoid blocking\n      trackAuthFailure(error?.message || \"No user found\", undefined, undefined).catch(() => {});\n      return { isAdmin: false, user: null };\n    }\n\n    const isAdmin = isAdminUser(user as AdminUser);\n    \n    if (!isAdmin) {\n      // Fire and forget - don't await to avoid blocking\n      trackAuthFailure(\"User is not an admin\", user.id, user.email).catch(() => {});\n    }\n\n    return { isAdmin, user: user as AdminUser };\n  } catch (err) {\n    logger.error(\"checkAdmin error:\", err);\n    // Fire and forget - don't await to avoid blocking\n    trackAuthFailure(\"checkAdmin exception\", undefined, undefined).catch(() => {});\n    return { isAdmin: false, user: null };\n  }\n}\n\n"],"names":[],"mappings":"AAAA,cAAc;AACd,oDAAoD;;;;;;;AAEpD;AAAA;AACA;AAAA;AAEA;AACA;AAEA;;;;;;AAOO,SAAS,YAAY,IAAkC;IAC5D,IAAI,CAAC,MAAM,OAAO;IAElB,MAAM,QAAS,KAAK,YAAY,EAAE,SAAS,KAAK,aAAa,EAAE,SAAS,EAAE;IAC1E,MAAM,OAAQ,KAAK,YAAY,EAAE,QAAQ,KAAK,aAAa,EAAE;IAC7D,OAAO,OAAO,SAAS,YAAY,SAAS,WAAW,KAAK,aAAa,EAAE,aAAa;AAC1F;AAOO,eAAe,WAAW,GAAgB;IAC/C,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,sLAAO;QACjC,MAAM,WAAW,IAAA,uMAAkB,EACjC,yHAAG,CAAC,wBAAwB,EAC5B,yHAAG,CAAC,6BAA6B,EACjC;YACE,SAAS;gBACP;oBACE,OAAO,YAAY,MAAM;gBAC3B;gBACA,QAAO,YAAY;oBACjB,IAAI;wBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,YAAY,GAAG,CAAC,MAAM,OAAO;oBAEjC,EAAE,OAAO,KAAK;wBACZ,6CAA6C;wBAC7C,+HAAM,CAAC,IAAI,CAAC,qBAAqB;oBACnC;gBACF;YACF;QACF;QAGF,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;QAE7D,IAAI,SAAS,CAAC,MAAM;YAClB,kDAAkD;YAClD,IAAA,4JAAgB,EAAC,OAAO,WAAW,iBAAiB,WAAW,WAAW,KAAK,CAAC,KAAO;YACvF,OAAO;gBAAE,SAAS;gBAAO,MAAM;YAAK;QACtC;QAEA,MAAM,UAAU,YAAY;QAE5B,IAAI,CAAC,SAAS;YACZ,kDAAkD;YAClD,IAAA,4JAAgB,EAAC,wBAAwB,KAAK,EAAE,EAAE,KAAK,KAAK,EAAE,KAAK,CAAC,KAAO;QAC7E;QAEA,OAAO;YAAE;YAAS,MAAM;QAAkB;IAC5C,EAAE,OAAO,KAAK;QACZ,+HAAM,CAAC,KAAK,CAAC,qBAAqB;QAClC,kDAAkD;QAClD,IAAA,4JAAgB,EAAC,wBAAwB,WAAW,WAAW,KAAK,CAAC,KAAO;QAC5E,OAAO;YAAE,SAAS;YAAO,MAAM;QAAK;IACtC;AACF"}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/ratelimit.ts"],"sourcesContent":["// lib/ratelimit.ts\n// Rate limiting configuration and utilities\n// Uses Upstash Redis for production, in-memory for development\n\nimport { Ratelimit } from \"@upstash/ratelimit\";\nimport { Redis } from \"@upstash/redis\";\nimport { logger } from \"./logger\";\n\n/**\n * Rate limiting strategy:\n * - Public API routes (/api/public/*): 10 requests per 10 seconds per IP\n *   This prevents abuse of public registration endpoints\n * \n * - Admin API routes (/api/admin/*): 100 requests per minute per user\n *   Higher limit for authenticated admin users, tracked by user ID\n */\n\n// Check if we're in development mode\nconst isDevelopment = process.env.NODE_ENV === \"development\";\n\n// Check if Redis is configured (optional - falls back to in-memory)\nconst redisUrl = process.env.UPSTASH_REDIS_REST_URL;\nconst redisToken = process.env.UPSTASH_REDIS_REST_TOKEN;\n\n/**\n * Redis client for rate limiting\n * Uses Upstash Redis if configured, otherwise uses a simple in-memory implementation\n */\nlet redis: Redis | null = null;\nlet useInMemory = false;\n\nif (redisUrl && redisToken) {\n  try {\n    redis = new Redis({\n      url: redisUrl,\n      token: redisToken,\n    });\n    logger.info(\"Rate limiting: Using Upstash Redis\");\n  } catch (error) {\n    logger.warn(\"Rate limiting: Failed to initialize Redis, using in-memory fallback\", error);\n    useInMemory = true;\n  }\n} else {\n  if (!isDevelopment) {\n    logger.warn(\"Rate limiting: Redis not configured, using in-memory storage (not recommended for production)\");\n  } else {\n    logger.info(\"Rate limiting: Using in-memory storage for development\");\n  }\n  useInMemory = true;\n}\n\n/**\n * Simple in-memory rate limiter for development\n * Implements sliding window algorithm\n */\nclass InMemoryRateLimiter {\n  private store: Map<string, number[]> = new Map();\n  private windowMs: number;\n  private maxRequests: number;\n\n  constructor(maxRequests: number, window: string) {\n    this.maxRequests = maxRequests;\n    // Parse window string (e.g., \"10 s\", \"1 m\")\n    const windowMatch = window.match(/^(\\d+)\\s*(s|m|h)$/);\n    if (!windowMatch) {\n      throw new Error(`Invalid window format: ${window}`);\n    }\n    const value = parseInt(windowMatch[1], 10);\n    const unit = windowMatch[2];\n    this.windowMs = value * (unit === \"s\" ? 1000 : unit === \"m\" ? 60000 : 3600000);\n  }\n\n  async limit(identifier: string): Promise<{ success: boolean; limit: number; remaining: number; reset: number }> {\n    const now = Date.now();\n    const key = identifier;\n    \n    if (!this.store.has(key)) {\n      this.store.set(key, []);\n    }\n    \n    const requests = this.store.get(key)!;\n    \n    // Remove requests outside the window\n    const cutoff = now - this.windowMs;\n    const validRequests = requests.filter((timestamp) => timestamp > cutoff);\n    \n    if (validRequests.length >= this.maxRequests) {\n      // Rate limit exceeded\n      const oldestRequest = Math.min(...validRequests);\n      const reset = oldestRequest + this.windowMs;\n      return {\n        success: false,\n        limit: this.maxRequests,\n        remaining: 0,\n        reset,\n      };\n    }\n    \n    // Add current request\n    validRequests.push(now);\n    this.store.set(key, validRequests);\n    \n    // Calculate reset time (oldest request + window)\n    const oldestRequest = validRequests.length > 0 ? Math.min(...validRequests) : now;\n    const reset = oldestRequest + this.windowMs;\n    \n    return {\n      success: true,\n      limit: this.maxRequests,\n      remaining: this.maxRequests - validRequests.length,\n      reset,\n    };\n  }\n}\n\n/**\n * Public API rate limiter\n * Limits: 10 requests per 10 seconds per IP address\n * Uses sliding window algorithm for smooth rate limiting\n */\nexport const publicApiLimiter = useInMemory\n  ? new InMemoryRateLimiter(10, \"10 s\")\n  : new Ratelimit({\n      redis: redis!,\n      limiter: Ratelimit.slidingWindow(10, \"10 s\"),\n      analytics: true,\n      prefix: \"@ratelimit/public-api\",\n    });\n\n/**\n * Admin API rate limiter\n * Limits: 100 requests per minute per user\n * Uses sliding window algorithm for smooth rate limiting\n */\nexport const adminApiLimiter = useInMemory\n  ? new InMemoryRateLimiter(100, \"1 m\")\n  : new Ratelimit({\n      redis: redis!,\n      limiter: Ratelimit.slidingWindow(100, \"1 m\"),\n      analytics: true,\n      prefix: \"@ratelimit/admin-api\",\n    });\n\n/**\n * Rate limit result type\n */\nexport interface RateLimitResult {\n  success: boolean;\n  limit: number;\n  remaining: number;\n  reset: number;\n}\n\n/**\n * Check rate limit for public API routes\n * @param identifier - IP address or other unique identifier\n * @returns Rate limit result with success status and metadata\n */\nexport async function checkPublicApiLimit(\n  identifier: string\n): Promise<RateLimitResult> {\n  try {\n    // Bypass rate limiting in development if explicitly disabled\n    if (isDevelopment && process.env.DISABLE_RATE_LIMIT === \"true\") {\n      return {\n        success: true,\n        limit: 10,\n        remaining: 10,\n        reset: Date.now() + 10000,\n      };\n    }\n\n    const result = await publicApiLimiter.limit(identifier);\n    return {\n      success: result.success,\n      limit: result.limit,\n      remaining: result.remaining,\n      reset: result.reset,\n    };\n  } catch (error) {\n    // On rate limiter failure, allow request through but log error\n    logger.error(\"Rate limiter error (public API):\", error);\n    return {\n      success: true,\n      limit: 10,\n      remaining: 10,\n      reset: Date.now() + 10000,\n    };\n  }\n}\n\n/**\n * Check rate limit for admin API routes\n * @param identifier - User ID or other unique identifier\n * @returns Rate limit result with success status and metadata\n */\nexport async function checkAdminApiLimit(\n  identifier: string\n): Promise<RateLimitResult> {\n  try {\n    // Bypass rate limiting in development if explicitly disabled\n    if (isDevelopment && process.env.DISABLE_RATE_LIMIT === \"true\") {\n      return {\n        success: true,\n        limit: 100,\n        remaining: 100,\n        reset: Date.now() + 60000,\n      };\n    }\n\n    const result = await adminApiLimiter.limit(identifier);\n    return {\n      success: result.success,\n      limit: result.limit,\n      remaining: result.remaining,\n      reset: result.reset,\n    };\n  } catch (error) {\n    // On rate limiter failure, allow request through but log error\n    logger.error(\"Rate limiter error (admin API):\", error);\n    return {\n      success: true,\n      limit: 100,\n      remaining: 100,\n      reset: Date.now() + 60000,\n    };\n  }\n}\n\n/**\n * Extract IP address from request\n * Handles various proxy headers and falls back to '127.0.0.1' if not found\n * @param req - NextRequest or Request object\n * @returns Client IP address\n */\nexport function getClientIp(req: Request | { ip?: string; headers: Headers }): string {\n  // Try NextRequest.ip property first (if available)\n  // Note: req.ip is not available in Next.js 16, so we always extract from headers\n\n  // Try to get IP from various headers (handles proxies, load balancers, etc.)\n  const headers = req.headers;\n  \n  // Check common proxy headers (in order of preference)\n  const forwardedFor = headers.get(\"x-forwarded-for\");\n  if (forwardedFor) {\n    // x-forwarded-for can contain multiple IPs, take the first one\n    const ip = forwardedFor.split(\",\")[0].trim();\n    if (ip) return ip;\n  }\n\n  const realIp = headers.get(\"x-real-ip\");\n  if (realIp) return realIp.trim();\n\n  const cfConnectingIp = headers.get(\"cf-connecting-ip\"); // Cloudflare\n  if (cfConnectingIp) return cfConnectingIp.trim();\n\n  // Fallback to localhost if no IP found\n  logger.warn(\"Could not determine client IP, using fallback\");\n  return \"127.0.0.1\";\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1006, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/sentry-context.ts"],"sourcesContent":["// lib/sentry-context.ts\n// Helper functions to set user context in Sentry\n\nimport * as Sentry from \"@sentry/nextjs\";\nimport { AdminUser } from \"@/types/auth\";\n\n/**\n * Set user context in Sentry for error tracking\n * @param user AdminUser object or null\n */\nexport function setSentryUser(user: AdminUser | null) {\n  try {\n    if (!user) {\n      Sentry.setUser(null);\n      return;\n    }\n\n    Sentry.setUser({\n      id: user.id,\n      email: user.email,\n      username: user.email,\n      // Add admin role to tags\n    });\n\n    Sentry.setTag(\"user_role\", \"admin\");\n    Sentry.setTag(\"user_id\", user.id);\n  } catch (error) {\n    // Silently fail if Sentry is not initialized\n    // This can happen in test environments or if Sentry is not configured\n  }\n}\n\n/**\n * Clear user context in Sentry\n */\nexport function clearSentryUser() {\n  try {\n    Sentry.setUser(null);\n    Sentry.setTag(\"user_role\", undefined);\n    Sentry.setTag(\"user_id\", undefined);\n  } catch (error) {\n    // Silently fail if Sentry is not initialized\n  }\n}\n\n/**\n * Add custom context to Sentry events\n */\nexport function addSentryContext(key: string, context: Record<string, any>) {\n  Sentry.setContext(key, context);\n}\n\n"],"names":[],"mappings":"AAAA,wBAAwB;AACxB,iDAAiD;;;;;;;;;AAEjD;;AAOO,SAAS,cAAc,IAAsB;IAClD,IAAI;QACF,IAAI,CAAC,MAAM;YACT,8KAAc,CAAC;YACf;QACF;QAEA,8KAAc,CAAC;YACb,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK;YACjB,UAAU,KAAK,KAAK;QAEtB;QAEA,6KAAa,CAAC,aAAa;QAC3B,6KAAa,CAAC,WAAW,KAAK,EAAE;IAClC,EAAE,OAAO,OAAO;IACd,6CAA6C;IAC7C,sEAAsE;IACxE;AACF;AAKO,SAAS;IACd,IAAI;QACF,8KAAc,CAAC;QACf,6KAAa,CAAC,aAAa;QAC3B,6KAAa,CAAC,WAAW;IAC3B,EAAE,OAAO,OAAO;IACd,6CAA6C;IAC/C;AACF;AAKO,SAAS,iBAAiB,GAAW,EAAE,OAA4B;IACxE,iLAAiB,CAAC,KAAK;AACzB"}},
    {"offset": {"line": 1052, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/csrf-edge.ts"],"sourcesContent":["// lib/csrf-edge.ts\n// CSRF protection utilities for Edge Runtime (middleware)\n// This file does NOT import Node.js crypto to maintain Edge Runtime compatibility\n\nimport { NextRequest, NextResponse } from \"next/server\";\n\nconst CSRF_COOKIE_NAME = \"__Host-csrf-token\";\nconst CSRF_HEADER_NAME = \"X-CSRF-Token\";\n\n/**\n * Get CSRF token from cookie (Edge Runtime compatible)\n * @param req - Next.js request object\n * @returns CSRF token from cookie or null\n */\nexport function getCsrfTokenFromCookie(req: NextRequest): string | null {\n  const cookie = req.cookies.get(CSRF_COOKIE_NAME);\n  return cookie?.value || null;\n}\n\n/**\n * Get CSRF token from header (Edge Runtime compatible)\n * @param req - Next.js request object\n * @returns CSRF token from header or null\n */\nexport function getCsrfTokenFromHeader(req: NextRequest): string | null {\n  return req.headers.get(CSRF_HEADER_NAME) || null;\n}\n\n/**\n * Verify CSRF token from request (Edge Runtime compatible)\n * Uses double-submit cookie pattern:\n * 1. Token must be in both cookie and header\n * 2. Both tokens must match\n * \n * NOTE: Full signature verification happens in API routes (Node.js runtime)\n * This function only checks cookie/header match for Edge Runtime compatibility\n * @param req - Next.js request object\n * @returns true if tokens match, false otherwise\n */\nexport function verifyCsrfRequest(req: NextRequest): boolean {\n  const cookieToken = getCsrfTokenFromCookie(req);\n  const headerToken = getCsrfTokenFromHeader(req);\n\n  // Both cookie and header must be present\n  if (!cookieToken || !headerToken) {\n    return false;\n  }\n\n  // Tokens must match (double-submit cookie pattern)\n  // Full signature verification happens in API routes\n  return cookieToken === headerToken;\n}\n\n/**\n * Check if request method requires CSRF protection\n * @param method - HTTP method\n * @returns true if method requires CSRF protection\n */\nexport function requiresCsrfProtection(method: string): boolean {\n  const safeMethods = [\"GET\", \"HEAD\", \"OPTIONS\"];\n  return !safeMethods.includes(method.toUpperCase());\n}\n\n/**\n * Middleware function to check CSRF protection (Edge Runtime compatible)\n * Returns error response if CSRF check fails, otherwise returns null\n * @param req - Next.js request object\n * @returns NextResponse with error if CSRF check fails, null otherwise\n */\nexport function checkCsrfProtection(req: NextRequest): NextResponse | null {\n  // Only check state-changing methods\n  if (!requiresCsrfProtection(req.method)) {\n    return null;\n  }\n\n  // Check CSRF token (cookie/header match only in Edge Runtime)\n  if (!verifyCsrfRequest(req)) {\n    return NextResponse.json(\n      {\n        ok: false,\n        error: \"CSRF token validation failed\",\n        code: \"CSRF_ERROR\",\n      },\n      { status: 403 }\n    );\n  }\n\n  return null;\n}\n\n"],"names":[],"mappings":"AAAA,mBAAmB;AACnB,0DAA0D;AAC1D,kFAAkF;;;;;;;;;;;;;AAElF;AAAA;;AAEA,MAAM,mBAAmB;AACzB,MAAM,mBAAmB;AAOlB,SAAS,uBAAuB,GAAgB;IACrD,MAAM,SAAS,IAAI,OAAO,CAAC,GAAG,CAAC;IAC/B,OAAO,QAAQ,SAAS;AAC1B;AAOO,SAAS,uBAAuB,GAAgB;IACrD,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,qBAAqB;AAC9C;AAaO,SAAS,kBAAkB,GAAgB;IAChD,MAAM,cAAc,uBAAuB;IAC3C,MAAM,cAAc,uBAAuB;IAE3C,yCAAyC;IACzC,IAAI,CAAC,eAAe,CAAC,aAAa;QAChC,OAAO;IACT;IAEA,mDAAmD;IACnD,oDAAoD;IACpD,OAAO,gBAAgB;AACzB;AAOO,SAAS,uBAAuB,MAAc;IACnD,MAAM,cAAc;QAAC;QAAO;QAAQ;KAAU;IAC9C,OAAO,CAAC,YAAY,QAAQ,CAAC,OAAO,WAAW;AACjD;AAQO,SAAS,oBAAoB,GAAgB;IAClD,oCAAoC;IACpC,IAAI,CAAC,uBAAuB,IAAI,MAAM,GAAG;QACvC,OAAO;IACT;IAEA,8DAA8D;IAC9D,IAAI,CAAC,kBAAkB,MAAM;QAC3B,OAAO,gMAAY,CAAC,IAAI,CACtB;YACE,IAAI;YACJ,OAAO;YACP,MAAM;QACR,GACA;YAAE,QAAQ;QAAI;IAElB;IAEA,OAAO;AACT"}},
    {"offset": {"line": 1119, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["// middleware.ts\nimport { NextResponse, type NextRequest } from \"next/server\";\nimport { createServerClient } from \"@supabase/ssr\";\nimport { isAdminUser, checkAdmin } from \"@/lib/auth\";\nimport { env } from \"@/lib/env\";\nimport {\n  checkPublicApiLimit,\n  checkAdminApiLimit,\n  getClientIp,\n} from \"@/lib/ratelimit\";\nimport { logger } from \"@/lib/logger\";\nimport * as Sentry from \"@sentry/nextjs\";\nimport { setSentryUser, clearSentryUser } from \"@/lib/sentry-context\";\nimport {\n  checkCsrfProtection,\n  requiresCsrfProtection,\n} from \"@/lib/csrf-edge\";\nimport { sanitizeHeaders } from \"@/lib/log-sanitizer\";\n\n/**\n * Generate a unique request ID\n */\nfunction generateRequestId(): string {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 9).toUpperCase();\n  return `REQ-${timestamp}-${random}`;\n}\n\n/**\n * Get request size in bytes (approximate)\n */\nfunction getRequestSize(req: NextRequest): number {\n  // Approximate size based on headers and URL\n  let size = req.url.length;\n  req.headers.forEach((value, key) => {\n    size += key.length + value.length;\n  });\n  return size;\n}\n\nexport async function middleware(req: NextRequest) {\n  const startTime = Date.now();\n  const requestId = generateRequestId();\n  const url = req.nextUrl;\n  const method = req.method;\n  const path = url.pathname;\n  const clientIp = getClientIp(req);\n  const userAgent = req.headers.get(\"user-agent\") || \"unknown\";\n\n  // Add request ID to response headers for correlation\n  const res = NextResponse.next();\n  res.headers.set(\"X-Request-ID\", requestId);\n\n  // Log request start\n  logger.info(\"Request started\", {\n    requestId,\n    method,\n    path,\n    ip: clientIp,\n    userAgent,\n    query: Object.fromEntries(url.searchParams),\n  });\n\n  // Rate limiting for public API routes\n  // Strategy: 10 requests per 10 seconds per IP address\n  if (url.pathname.startsWith(\"/api/public/\")) {\n    // Extract IP from headers\n    const clientIp = getClientIp(req);\n    const rateLimitResult = await checkPublicApiLimit(clientIp);\n\n    if (!rateLimitResult.success) {\n      // Rate limit exceeded - return 429 Too Many Requests\n      const resetTime = new Date(rateLimitResult.reset).toISOString();\n      const duration = Date.now() - startTime;\n      \n      logger.request({\n        method,\n        path,\n        statusCode: 429,\n        duration,\n        ip: clientIp,\n        userAgent,\n      });\n      logger.warn(\"Rate limit exceeded for public API\", {\n        requestId,\n        ip: clientIp,\n        path,\n      });\n\n      const errorResponse = NextResponse.json(\n        {\n          error: \"Too Many Requests\",\n          message: \"Rate limit exceeded. Please try again later.\",\n          limit: rateLimitResult.limit,\n          remaining: rateLimitResult.remaining,\n          reset: resetTime,\n        },\n        {\n          status: 429,\n          headers: {\n            \"X-Request-ID\": requestId,\n            \"X-RateLimit-Limit\": rateLimitResult.limit.toString(),\n            \"X-RateLimit-Remaining\": rateLimitResult.remaining.toString(),\n            \"X-RateLimit-Reset\": rateLimitResult.reset.toString(),\n            \"Retry-After\": Math.ceil((rateLimitResult.reset - Date.now()) / 1000).toString(),\n          },\n        }\n      );\n      return errorResponse;\n    }\n\n    // Add rate limit headers to successful responses\n    res.headers.set(\"X-RateLimit-Limit\", rateLimitResult.limit.toString());\n    res.headers.set(\"X-RateLimit-Remaining\", rateLimitResult.remaining.toString());\n    res.headers.set(\"X-RateLimit-Reset\", rateLimitResult.reset.toString());\n\n    return res;\n  }\n\n  // Rate limiting and CSRF protection for admin API routes\n  // Strategy: 100 requests per minute per authenticated user\n  if (url.pathname.startsWith(\"/api/admin/\")) {\n    // CSRF protection for state-changing requests\n    // Exempt GET/HEAD/OPTIONS requests\n    if (requiresCsrfProtection(req.method)) {\n      const csrfError = checkCsrfProtection(req);\n      if (csrfError) {\n        logger.warn(`CSRF validation failed for ${req.method} ${url.pathname}`);\n        return csrfError;\n      }\n    }\n\n    // CSRF token generation happens in /api/csrf-token endpoint (Node.js runtime)\n    // Middleware only checks token presence and match (Edge Runtime compatible)\n\n    // First check authentication to get user ID\n    const { isAdmin, user } = await checkAdmin(req);\n\n    // Set user context in Sentry for admin API routes\n    if (user) {\n      setSentryUser(user);\n    } else {\n      clearSentryUser();\n    }\n\n    if (!isAdmin || !user) {\n      // Authentication will be handled by the API route itself\n      // We still need to check rate limit, but use IP as fallback\n      const rateLimitResult = await checkPublicApiLimit(clientIp);\n\n      if (!rateLimitResult.success) {\n        const duration = Date.now() - startTime;\n        logger.request({\n          method,\n          path,\n          statusCode: 429,\n          duration,\n          ip: clientIp,\n          userAgent,\n        });\n        logger.warn(\"Rate limit exceeded for admin API (unauthenticated)\", {\n          requestId,\n          ip: clientIp,\n          path,\n        });\n\n        return NextResponse.json(\n          {\n            error: \"Too Many Requests\",\n            message: \"Rate limit exceeded. Please try again later.\",\n            limit: rateLimitResult.limit,\n            remaining: rateLimitResult.remaining,\n            reset: new Date(rateLimitResult.reset).toISOString(),\n          },\n          {\n            status: 429,\n            headers: {\n              \"X-Request-ID\": requestId,\n              \"X-RateLimit-Limit\": rateLimitResult.limit.toString(),\n              \"X-RateLimit-Remaining\": rateLimitResult.remaining.toString(),\n              \"X-RateLimit-Reset\": rateLimitResult.reset.toString(),\n              \"Retry-After\": Math.ceil((rateLimitResult.reset - Date.now()) / 1000).toString(),\n            },\n          }\n        );\n      }\n\n      res.headers.set(\"X-RateLimit-Limit\", rateLimitResult.limit.toString());\n      res.headers.set(\"X-RateLimit-Remaining\", rateLimitResult.remaining.toString());\n      res.headers.set(\"X-RateLimit-Reset\", rateLimitResult.reset.toString());\n      \n      // Log successful request (authentication will be checked in route)\n      const duration = Date.now() - startTime;\n      logger.request({\n        method,\n        path,\n        statusCode: 200,\n        duration,\n        ip: clientIp,\n        userAgent,\n      });\n      \n      return res;\n    }\n\n    // Use user ID for rate limiting (more accurate than IP for authenticated users)\n    const userId = user.id;\n    const rateLimitResult = await checkAdminApiLimit(userId);\n\n    if (!rateLimitResult.success) {\n      // Rate limit exceeded - return 429 Too Many Requests\n      const resetTime = new Date(rateLimitResult.reset).toISOString();\n      const duration = Date.now() - startTime;\n      \n      logger.request({\n        method,\n        path,\n        statusCode: 429,\n        duration,\n        ip: clientIp,\n        userAgent,\n        userId,\n      });\n      logger.warn(\"Rate limit exceeded for admin API\", {\n        requestId,\n        userId,\n        path,\n      });\n\n      return NextResponse.json(\n        {\n          error: \"Too Many Requests\",\n          message: \"Rate limit exceeded. Please try again later.\",\n          limit: rateLimitResult.limit,\n          remaining: rateLimitResult.remaining,\n          reset: resetTime,\n        },\n        {\n          status: 429,\n          headers: {\n            \"X-Request-ID\": requestId,\n            \"X-RateLimit-Limit\": rateLimitResult.limit.toString(),\n            \"X-RateLimit-Remaining\": rateLimitResult.remaining.toString(),\n            \"X-RateLimit-Reset\": rateLimitResult.reset.toString(),\n            \"Retry-After\": Math.ceil((rateLimitResult.reset - Date.now()) / 1000).toString(),\n          },\n        }\n      );\n    }\n\n    // Add rate limit headers to successful responses\n    res.headers.set(\"X-RateLimit-Limit\", rateLimitResult.limit.toString());\n    res.headers.set(\"X-RateLimit-Remaining\", rateLimitResult.remaining.toString());\n    res.headers.set(\"X-RateLimit-Reset\", rateLimitResult.reset.toString());\n\n    // Log successful request\n    const duration = Date.now() - startTime;\n    logger.request({\n      method,\n      path,\n      statusCode: 200,\n      duration,\n      ip: clientIp,\n      userAgent,\n      userId,\n    });\n\n    return res;\n  }\n\n  // Log all requests at the end (if not already logged)\n  // This ensures we log even if the request doesn't match any specific route\n  const duration = Date.now() - startTime;\n  if (!res.headers.has(\"X-Request-ID\")) {\n    res.headers.set(\"X-Request-ID\", requestId);\n  }\n\n  // Log request completion (will be logged by route handlers for API routes)\n  if (!path.startsWith(\"/api/\")) {\n    logger.request({\n      method,\n      path,\n      statusCode: res.status || 200,\n      duration,\n      ip: clientIp,\n      userAgent,\n    });\n  }\n\n  // Existing admin page protection logic\n  if (url.pathname.startsWith(\"/admin\")) {\n    const supabase = createServerClient(\n      env.NEXT_PUBLIC_SUPABASE_URL,\n      env.NEXT_PUBLIC_SUPABASE_ANON_KEY,\n      {\n        cookies: {\n          getAll() {\n            return req.cookies.getAll();\n          },\n          setAll(cookiesToSet) {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              res.cookies.set(name, value, options);\n            });\n          },\n        },\n      }\n    );\n    const { data: { user } } = await supabase.auth.getUser();\n\n    if (!user) {\n      const loginUrl = new URL(\"/auth\", req.url);\n      loginUrl.searchParams.set(\"redirectedFrom\", url.pathname);\n      return NextResponse.redirect(loginUrl);\n    }\n    if (!isAdminUser(user)) {\n      const denied = new URL(\"/auth\", req.url);\n      denied.searchParams.set(\"error\", \"forbidden\");\n      denied.searchParams.set(\"redirectedFrom\", url.pathname);\n      return NextResponse.redirect(denied);\n    }\n    return res;\n  }\n\n  // Existing auth page logic\n  if (url.pathname === \"/auth\") {\n    const supabase = createServerClient(\n      env.NEXT_PUBLIC_SUPABASE_URL,\n      env.NEXT_PUBLIC_SUPABASE_ANON_KEY,\n      {\n        cookies: {\n          getAll() {\n            return req.cookies.getAll();\n          },\n          setAll(cookiesToSet) {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              res.cookies.set(name, value, options);\n            });\n          },\n        },\n      }\n    );\n    const { data: { user } } = await supabase.auth.getUser();\n    if (user && isAdminUser(user)) {\n      const to = url.searchParams.get(\"redirectedFrom\") || \"/admin\";\n      return NextResponse.redirect(new URL(to, req.url));\n    }\n  }\n\n  return res;\n}\n\n// Updated matcher to include API routes for rate limiting\nexport const config = {\n  matcher: [\n    \"/admin/:path*\",\n    \"/auth\",\n    \"/api/public/:path*\",\n    \"/api/admin/:path*\",\n  ],\n};\n"],"names":[],"mappings":"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"}}]
}