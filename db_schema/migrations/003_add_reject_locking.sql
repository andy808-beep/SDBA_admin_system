-- =========================================================
-- Migration: 003_add_reject_locking.sql
-- Date: 2024-12-11
-- Description: Add explicit row-level locking to reject_registration function
--              to prevent race conditions when multiple admins reject the same
--              registration simultaneously. Matches the pattern used in approve_registration.
-- =========================================================
-- 
-- Changes:
--   - Add DECLARE section with reg_record variable
--   - Add SELECT ... FOR UPDATE SKIP LOCKED before UPDATE
--   - Update error handling to match approve_registration pattern
--   - Add verification that UPDATE succeeded
--   - Update function comments
--   - Ensure consistent error messages and ERRCODE usage (P0001)
--   - Ensure consistent HINT messages mentioning concurrent processing
--
-- Expected behavior:
--   - When two admins reject the same registration simultaneously:
--     * First admin gets the lock and succeeds
--     * Second admin gets "Registration not found or not pending" error
--     * Only one rejection is processed
--     * No race condition
--
-- Idempotency: Safe to run multiple times (uses CREATE OR REPLACE)
-- =========================================================

BEGIN;

-- Update reject_registration function with row-level locking
CREATE OR REPLACE FUNCTION public.reject_registration(reg_id uuid, admin_user_id uuid, notes text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  reg_record public.registration_meta%ROWTYPE;
BEGIN
  -- Get the registration record with row-level lock to prevent race conditions
  -- SKIP LOCKED allows other transactions to proceed if this row is already locked
  SELECT * INTO reg_record
  FROM public.registration_meta
  WHERE id = reg_id AND status = 'pending'
  FOR UPDATE SKIP LOCKED;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION USING 
      ERRCODE = 'P0001',
      MESSAGE = 'Registration not found or not pending',
      HINT = format('Registration %s is not in pending status or is being processed by another admin', reg_id);
  END IF;
  
  -- Update registration status (verify update succeeded)
  UPDATE public.registration_meta
  SET 
    status = 'rejected',
    admin_notes = notes,
    approved_by = admin_user_id,
    approved_at = now()
  WHERE id = reg_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'Failed to update registration status',
      HINT = format('Registration %s could not be updated', reg_id);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    -- Re-raise the exception with context
    RAISE;
END;
$$;

-- Update approve_registration function to ensure consistent error handling
CREATE OR REPLACE FUNCTION public.approve_registration(reg_id uuid, admin_user_id uuid, notes text DEFAULT NULL)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  reg_record public.registration_meta%ROWTYPE;
  new_team_id uuid;
BEGIN
  -- Get the registration record with row-level lock to prevent race conditions
  -- SKIP LOCKED allows other transactions to proceed if this row is already locked
  SELECT * INTO reg_record
  FROM public.registration_meta
  WHERE id = reg_id AND status = 'pending'
  FOR UPDATE SKIP LOCKED;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION USING 
      ERRCODE = 'P0001',
      MESSAGE = 'Registration not found or not pending',
      HINT = format('Registration %s is not in pending status or is being processed by another admin', reg_id);
  END IF;
  
  -- Route to appropriate team table based on event_type
  IF reg_record.event_type = 'tn' THEN
    -- Insert into team_meta for TN
    -- NOTE: team_name_normalized is GENERATED ALWAYS and cannot be inserted manually
    INSERT INTO public.team_meta (
      user_id, season, category, division_code, option_choice,
      team_code, team_name, org_name, org_address,
      team_manager_1, mobile_1, email_1,
      team_manager_2, mobile_2, email_2,
      team_manager_3, mobile_3, email_3,
      registration_id
    ) VALUES (
      reg_record.user_id, reg_record.season, reg_record.category, reg_record.division_code, reg_record.option_choice,
      reg_record.team_code, reg_record.team_name, reg_record.org_name, reg_record.org_address,
      reg_record.team_manager_1, reg_record.mobile_1, reg_record.email_1,
      reg_record.team_manager_2, reg_record.mobile_2, reg_record.email_2,
      reg_record.team_manager_3, reg_record.mobile_3, reg_record.email_3,
      reg_record.id
    ) RETURNING id INTO new_team_id;
    
  ELSIF reg_record.event_type = 'wu' THEN
    -- Insert into wu_team_meta for WU (team_code will be auto-generated by trigger)
    INSERT INTO public.wu_team_meta (
      user_id, season, division_code,
      team_code, team_name,
      package_choice, team_size,
      team_manager, mobile, email,
      org_name, org_address,
      registration_id
    ) VALUES (
      reg_record.user_id, reg_record.season, reg_record.division_code,
      '', reg_record.team_name,  -- Empty team_code will trigger auto-generation
      reg_record.package_choice, reg_record.team_size,
      reg_record.team_manager_1, reg_record.mobile_1, reg_record.email_1,
      reg_record.org_name, reg_record.org_address,
      reg_record.id
    ) RETURNING id INTO new_team_id;
    
  ELSIF reg_record.event_type = 'sc' THEN
    -- Insert into sc_team_meta for SC (team_code will be auto-generated by trigger)
    INSERT INTO public.sc_team_meta (
      user_id, season, division_code,
      team_code, team_name,
      package_choice, team_size,
      team_manager, mobile, email,
      org_name, org_address,
      registration_id
    ) VALUES (
      reg_record.user_id, reg_record.season, reg_record.division_code,
      '', reg_record.team_name,  -- Empty team_code will trigger auto-generation
      reg_record.package_choice, reg_record.team_size,
      reg_record.team_manager_1, reg_record.mobile_1, reg_record.email_1,
      reg_record.org_name, reg_record.org_address,
      reg_record.id
    ) RETURNING id INTO new_team_id;
    
  ELSE
    RAISE EXCEPTION 'Unknown event_type: %', reg_record.event_type;
  END IF;
  
  -- Update registration status (verify update succeeded)
  UPDATE public.registration_meta
  SET 
    status = 'approved',
    admin_notes = notes,
    approved_by = admin_user_id,
    approved_at = now()
  WHERE id = reg_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION USING
      ERRCODE = 'P0001',
      MESSAGE = 'Failed to update registration status',
      HINT = format('Registration %s could not be updated', reg_id);
  END IF;
  
  RETURN new_team_id;
EXCEPTION
  WHEN OTHERS THEN
    -- Re-raise the exception with context
    RAISE;
END;
$$;

-- Add function comments documenting concurrency protection
COMMENT ON FUNCTION public.reject_registration(uuid, uuid, text) IS 
'Rejects a pending registration. Uses explicit row-level locking (FOR UPDATE SKIP LOCKED) to prevent race conditions when multiple admins attempt to reject the same registration simultaneously. The first admin to acquire the lock succeeds; subsequent attempts receive an error indicating the registration is not in pending status or is being processed.';

COMMENT ON FUNCTION public.approve_registration(uuid, uuid, text) IS 
'Approves a pending registration and moves it to the appropriate team table based on event_type. Uses explicit row-level locking (FOR UPDATE SKIP LOCKED) to prevent race conditions when multiple admins attempt to approve the same registration simultaneously. The first admin to acquire the lock succeeds; subsequent attempts receive an error indicating the registration is not in pending status or is being processed.';

-- Record migration
INSERT INTO public.schema_migrations (version, description)
VALUES ('003_add_reject_locking', 'Add explicit row-level locking to reject_registration function and ensure consistent error handling in both approve and reject functions')
ON CONFLICT (version) DO NOTHING;

COMMIT;

